

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>diffct.differentiable &mdash; diffct  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            diffct
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffct</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">diffct.differentiable</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for diffct.differentiable</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">cuda</span>

<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># Global settings &amp; helpers</span>
<span class="c1"># ---------------------------------------------------------------------------</span>

<span class="n">_DTYPE</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="c1"># CUDA thread block configurations optimized for different dimensionalities</span>
<span class="c1"># 2D blocks: 16x16 = 256 threads per block, optimal for 2D ray-tracing kernels</span>
<span class="c1"># Balances occupancy with shared memory usage for parallel/fan beam projections</span>
<span class="n">_TPB_2D</span>             <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1"># 3D blocks: 8x8x8 = 512 threads per block, optimal for 3D cone beam kernels  </span>
<span class="c1"># Smaller per-dimension size accommodates higher register usage in 3D algorithms</span>
<span class="n">_TPB_3D</span>             <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">8</span><span class="p">)</span>
<span class="c1"># CUDA fastmath optimization: enables aggressive floating-point optimizations</span>
<span class="c1"># Trades numerical precision for performance in ray-tracing calculations</span>
<span class="c1"># Safe for CT reconstruction where slight precision loss is acceptable for speed gains</span>
<span class="n">_FASTMATH_DECORATOR</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_INF</span>                <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">_EPSILON</span>            <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span>
<span class="c1"># === Device Management Utilities ===</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DeviceManager</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_device</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the device on which a PyTorch tensor resides.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            The tensor whose device is to be determined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.device</span>
<span class="sd">            The device of the tensor. Returns &#39;cpu&#39; if the tensor does not</span>
<span class="sd">            have a device attribute.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DeviceManager.get_device(torch.tensor([1, 2, 3]))</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tensor</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_device</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure that a tensor is on the specified device.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            The tensor to move.</span>
<span class="sd">        device : torch.device</span>
<span class="sd">            The target device.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The tensor on the specified device. If the tensor is already on</span>
<span class="sd">            the device, it is returned unchanged.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DeviceManager.ensure_device(</span>
<span class="sd">        ...     torch.tensor([1, 2, 3]),</span>
<span class="sd">        ...     torch.device(&#39;cuda&#39;)</span>
<span class="sd">        ... )</span>
<span class="sd">        tensor([1, 2, 3], device=&#39;cuda:0&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tensor</span> <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">device</span> <span class="k">else</span> <span class="n">tensor</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor</span>

<span class="c1"># === PyTorch-CUDA Bridge ===</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TorchCUDABridge</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tensor_to_cuda_array</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a PyTorch CUDA tensor to a Numba CUDA array.</span>

<span class="sd">        This function provides a zero-copy view of a PyTorch tensor as a Numba</span>
<span class="sd">        CUDA array, avoiding any data transfer to the CPU. The tensor is</span>
<span class="sd">        always detached to prevent autograd-related issues.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            A PyTorch tensor located on a CUDA device.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">            A Numba CUDA array view of the tensor&#39;s data.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the tensor is not on a CUDA device.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned array shares memory with the original tensor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; t = torch.randn(10, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr = TorchCUDABridge.tensor_to_cuda_array(t)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tensor</span><span class="o">.</span><span class="n">is_cuda</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tensor must be on CUDA device&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cuda</span><span class="o">.</span><span class="n">as_cuda_array</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cuda_array_to_tensor</span><span class="p">(</span><span class="n">cuda_array</span><span class="p">,</span> <span class="n">tensor_template</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a Numba CUDA array to a PyTorch tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cuda_array : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">            The CUDA array to convert.</span>
<span class="sd">        tensor_template : torch.Tensor</span>
<span class="sd">            A PyTorch tensor whose device and dtype will be used for the new</span>
<span class="sd">            tensor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            A PyTorch tensor sharing data with the CUDA array, configured</span>
<span class="sd">            with the device and dtype of the template tensor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = cuda.device_array((10,), dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; t = torch.zeros(10, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_t = TorchCUDABridge.cuda_array_to_tensor(arr, t)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">cuda_array</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">tensor_template</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_template</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="c1"># === GPU-aware Trigonometric Table Generation ===</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_DTYPE</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Precompute trigonometric lookup tables and transfer to GPU.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angles : array-like or torch.Tensor</span>
<span class="sd">        Array of projection angles in radians. It can be a NumPy array or a</span>
<span class="sd">        PyTorch tensor on either CPU or CUDA.</span>
<span class="sd">    dtype : np.dtype or torch.dtype, optional</span>
<span class="sd">        The desired data type for the output tables. Defaults to `_DTYPE`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cos : torch.Tensor</span>
<span class="sd">        A tensor containing the cosine of the input angles, located on the</span>
<span class="sd">        same device as the input.</span>
<span class="sd">    sin : torch.Tensor</span>
<span class="sd">        A tensor containing the sine of the input angles, located on the</span>
<span class="sd">        same device as the input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cos, sin = _trig_tables(angles)</span>
<span class="sd">    &gt;&gt;&gt; cos.device</span>
<span class="sd">    device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">device</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cos</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">sin</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fallback for numpy arrays</span>
        <span class="n">cos_host</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sin_host</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">cos_host</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">sin_host</span><span class="p">)</span>




<span class="k">def</span><span class="w"> </span><span class="nf">_grid_2d</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">tpb</span><span class="o">=</span><span class="n">_TPB_2D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the CUDA 2D grid and block configuration.</span>

<span class="sd">    This function determines the optimal thread organization for 2D</span>
<span class="sd">    ray-tracing kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n1 : int</span>
<span class="sd">        The number of elements along the first dimension (e.g., projection</span>
<span class="sd">        angles).</span>
<span class="sd">    n2 : int</span>
<span class="sd">        The number of elements along the second dimension (e.g., detector</span>
<span class="sd">        elements).</span>
<span class="sd">    tpb : tuple of int, optional</span>
<span class="sd">        The number of threads per block, defaulting to `_TPB_2D`. This value</span>
<span class="sd">        is chosen to optimize occupancy and shared memory usage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : tuple of int</span>
<span class="sd">        A tuple representing the grid dimensions (number of blocks) for each</span>
<span class="sd">        axis.</span>
<span class="sd">    tpb : tuple of int</span>
<span class="sd">        A tuple representing the block dimensions (threads per block) for</span>
<span class="sd">        each axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Each thread is assigned to a single ray, identified by a unique</span>
<span class="sd">      (projection angle, detector element) pair.</span>
<span class="sd">    - Grid dimensions are computed to ensure full coverage of all rays while</span>
<span class="sd">      minimizing thread divergence.</span>
<span class="sd">    - The default block size of 16x16 is selected to maximize GPU</span>
<span class="sd">      occupancy while staying within shared memory limits.</span>
<span class="sd">    - Threads within the same warp are assigned to adjacent detector</span>
<span class="sd">      elements to promote coalesced memory access.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid, tpb = _grid_2d(180, 256)</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    (12, 16)</span>
<span class="sd">    &gt;&gt;&gt; tpb</span>
<span class="sd">    (16, 16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n1</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n2</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">tpb</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_grid_3d</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">tpb</span><span class="o">=</span><span class="n">_TPB_3D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the CUDA 3D grid and block configuration.</span>

<span class="sd">    This function determines the optimal thread organization for 3D cone-beam</span>
<span class="sd">    kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n1 : int</span>
<span class="sd">        The number of elements along the first dimension (e.g., projection</span>
<span class="sd">        views).</span>
<span class="sd">    n2 : int</span>
<span class="sd">        The number of elements along the second dimension (e.g., detector</span>
<span class="sd">        u-axis).</span>
<span class="sd">    n3 : int</span>
<span class="sd">        The number of elements along the third dimension (e.g., detector</span>
<span class="sd">        v-axis).</span>
<span class="sd">    tpb : tuple of int, optional</span>
<span class="sd">        The number of threads per block, defaulting to `_TPB_3D`. This value</span>
<span class="sd">        is chosen to balance occupancy and register usage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : tuple of int</span>
<span class="sd">        A tuple representing the grid dimensions (number of blocks) for each</span>
<span class="sd">        axis.</span>
<span class="sd">    tpb : tuple of int</span>
<span class="sd">        A tuple representing the block dimensions (threads per block) for</span>
<span class="sd">        each axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Each thread processes a single ray, defined by a (view, detector_u,</span>
<span class="sd">      detector_v) triplet.</span>
<span class="sd">    - The 3D grid is designed to map directly to the 3D detector array,</span>
<span class="sd">      providing an intuitive thread-to-ray correspondence.</span>
<span class="sd">    - The 8x8x8 block size is chosen to balance occupancy with the higher</span>
<span class="sd">      register pressure typical of 3D calculations.</span>
<span class="sd">    - The use of 3D thread indexing facilitates efficient traversal of the</span>
<span class="sd">      detector array and promotes memory coalescing.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid, tpb = _grid_3d(360, 256, 256)</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    (45, 32, 32)</span>
<span class="sd">    &gt;&gt;&gt; tpb</span>
<span class="sd">    (8, 8, 8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n1</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n2</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n3</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
    <span class="p">),</span> <span class="n">tpb</span>


<span class="c1"># ############################################################################</span>
<span class="c1"># SHARED CUDA KERNELS</span>
<span class="c1"># ############################################################################</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 2-D PARALLEL BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_parallel_2d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph ray-tracing algorithm for</span>
<span class="sd">    2D parallel beam forward projection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The Siddon-Joseph algorithm provides accurate ray-volume intersection</span>
<span class="sd">        by:</span>
<span class="sd">        1. Calculating ray-volume boundary intersections to define traversal</span>
<span class="sd">           limits.</span>
<span class="sd">        2. Iterating through voxels along the ray path via parametric</span>
<span class="sd">           equations.</span>
<span class="sd">        3. Determining bilinear interpolation weights for sub-voxel</span>
<span class="sd">           sampling.</span>
<span class="sd">        4. Aggregating weighted voxel values based on ray segment lengths.</span>

<span class="sd">        The mathematical foundation relies on the parametric ray equation</span>
<span class="sd">        :math:`\mathbf{r}(t) = \text{start} + t \cdot \text{direction}`,</span>
<span class="sd">        where the algorithm identifies intersections with voxel boundaries</span>
<span class="sd">        and integrates the volume function along the ray.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># CUDA THREAD ORGANIZATION: 2D grid maps directly to ray geometry</span>
    <span class="c1"># Each thread processes one ray defined by (projection_angle, detector_element) pair</span>
    <span class="c1"># Thread indexing: iang = projection angle index, idet = detector element index</span>
    <span class="c1"># Memory access pattern: Threads in same warp access consecutive detector elements (coalesced)</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === RAY GEOMETRY SETUP ===</span>
    <span class="c1"># Extract projection angle and compute detector position</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Define ray direction and starting point for parallel beam geometry</span>
    <span class="c1"># Ray direction is perpendicular to detector array (cos_a, sin_a)</span>
    <span class="c1"># Ray starting point is offset along detector by distance u</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span>
    <span class="n">pnt_x</span><span class="p">,</span> <span class="n">pnt_y</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_a</span><span class="p">,</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute parametric intersection points with volume boundaries using ray equation r(t) = pnt + t*dir</span>
    <span class="c1"># Volume extends from [-cx, cx] x [-cy, cy] in image coordinate system</span>
    <span class="c1"># Mathematical basis: For ray r(t) = origin + t*direction, solve r(t) = boundary for parameter t</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>  <span class="c1"># Initialize ray parameter range to unbounded</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="c1"># Handle non-parallel rays: compute intersection parameters with left (-cx) and right (+cx) boundaries</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Ray not parallel to x-axis (avoid division by zero)</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>  <span class="c1"># Left and right boundary intersections</span>
        <span class="c1"># Update valid parameter range: intersection of current range with x-boundary constraints</span>
        <span class="c1"># min/max operations ensure we get the entry/exit points correctly regardless of ray direction</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>  <span class="c1"># Update valid parameter range</span>
    <span class="k">elif</span> <span class="n">pnt_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">pnt_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Ray parallel to x-axis but outside volume bounds</span>
        <span class="c1"># Edge case: ray never intersects volume if parallel and outside boundaries</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># Y-direction boundary intersections (identical logic to x-direction)</span>
    <span class="c1"># Handle non-parallel rays: compute intersection parameters with bottom (-cy) and top (+cy) boundaries</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Ray not parallel to y-axis (avoid division by zero)</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>  <span class="c1"># Bottom and top boundary intersections</span>
        <span class="c1"># Intersect y-boundary constraints with existing parameter range from x-boundaries</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>  <span class="c1"># Intersect with x-range</span>
    <span class="k">elif</span> <span class="n">pnt_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">pnt_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>  <span class="c1"># Ray parallel to y-axis but outside volume bounds</span>
        <span class="c1"># Edge case: ray never intersects volume if parallel and outside boundaries</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># Boundary intersection validation: check if ray actually intersects the volume</span>
    <span class="c1"># If t_min &gt;= t_max, the ray misses the volume entirely (no valid intersection interval)</span>
    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH VOXEL TRAVERSAL INITIALIZATION ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value along ray</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter (distance from ray start)</span>
    
    <span class="c1"># Convert ray entry point to voxel indices (image coordinate system)</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>

    <span class="c1"># Determine traversal direction and step sizes for each axis</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Voxel stepping direction</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment to cross one voxel in x</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment to cross one voxel in y</span>
    
    <span class="c1"># Calculate parameter values for next voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Next x-boundary crossing</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Next y-boundary crossing</span>

    <span class="c1"># === MAIN RAY TRAVERSAL LOOP ===</span>
    <span class="c1"># Step through voxels along ray path, accumulating weighted contributions</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next voxel boundary crossing (minimum of x, y boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>  <span class="c1"># Length of ray segment within current voxel region</span>
            
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Only process segments with meaningful length (avoid numerical noise)</span>
                <span class="c1"># === BILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample volume at ray segment midpoint for accurate integration</span>
                <span class="c1"># Mathematical basis: Midpoint rule for numerical integration along ray segments</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">pnt_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate in image space</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">pnt_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate in image space</span>
                
                <span class="c1"># Convert continuous coordinates to discrete voxel indices and fractional weights</span>
                <span class="c1"># Floor operation gives base voxel index, fractional part gives interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>  <span class="c1"># Base voxel indices (bottom-left corner)</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>  <span class="c1"># Fractional parts: distance from base voxel center [0,1]</span>
                
                <span class="c1"># === BILINEAR INTERPOLATION WEIGHT CALCULATION ===</span>
                <span class="c1"># Mathematical basis: Bilinear interpolation formula f(x,y) = Σ f(xi,yi) * wi(x,y)</span>
                <span class="c1"># where wi(x,y) are the bilinear basis functions for each corner voxel</span>
                <span class="c1"># Weights are products of 1D linear interpolation weights: (1-dx) or dx, (1-dy) or dy</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>  <span class="c1"># Bottom-left:  weight = distance from opposite corner</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">]</span>     <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>  <span class="c1"># Bottom-right: weight = dx * (1-dy)</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>       <span class="o">+</span>  <span class="c1"># Top-left:     weight = (1-dx) * dy  </span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span>          <span class="c1"># Top-right:    weight = dx * dy</span>
                <span class="p">)</span>
                <span class="c1"># Accumulate contribution weighted by ray segment length (discrete line integral approximation)</span>
                <span class="c1"># This implements the Radon transform: integral of f(x,y) along the ray path</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>
        
        <span class="c1"># === VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>  <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>  <span class="c1"># Move to next voxel in x-direction</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>    <span class="c1"># Update next x-boundary crossing parameter</span>
        <span class="k">else</span><span class="p">:</span>         <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>  <span class="c1"># Move to next voxel in y-direction</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>    <span class="c1"># Update next y-boundary crossing parameter</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_parallel_2d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D parallel</span>
<span class="sd">    beam backprojection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This operation is the adjoint of the forward projection, where</span>
<span class="sd">        sinogram values are distributed back into the volume along identical</span>
<span class="sd">        ray paths. It employs the same ray-tracing logic but utilizes atomic</span>
<span class="sd">        operations to manage concurrent writes from multiple threads.</span>

<span class="sd">        The mathematical foundation is based on implementing the transpose of</span>
<span class="sd">        the forward projection matrix, which distributes detector</span>
<span class="sd">        measurements back along ray paths using bilinear interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === RAY GEOMETRY SETUP (identical to forward projection) ===</span>
    <span class="n">val</span>   <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Define ray direction and starting point for parallel beam geometry</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span>
    <span class="n">pnt_x</span><span class="p">,</span> <span class="n">pnt_y</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_a</span><span class="p">,</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION (identical to forward) ===</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">pnt_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">pnt_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">pnt_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">pnt_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along ray path using bilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at ray segment midpoint (same as forward projection)</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">pnt_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">pnt_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH BILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA ATOMIC OPERATIONS: Essential for thread safety in backprojection</span>
                <span class="c1"># Multiple threads (rays) can write to the same voxel simultaneously, causing race conditions</span>
                <span class="c1"># Atomic add operations serialize these writes, ensuring correct accumulation of contributions</span>
                <span class="c1"># Performance impact: Atomic operations are slower than regular writes but necessary for correctness</span>
                <span class="c1"># Memory access pattern: Global memory atomics with potential bank conflicts, but unavoidable</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>  <span class="c1"># Bottom-left corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>  <span class="c1"># Bottom-right corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>        <span class="c1"># Top-left corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>        <span class="c1"># Top-right corner atomic write</span>

        <span class="c1"># Advance to next voxel (identical logic to forward projection)</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 2-D FAN BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_fan_2d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D fan beam</span>
<span class="sd">    forward projection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Fan beam geometry diverges from parallel beam in that its rays</span>
<span class="sd">        originate from a single point source, forming a divergent beam</span>
<span class="sd">        pattern as they connect the X-ray source to each detector element.</span>
<span class="sd">        While this kernel uses the same Siddon-Joseph traversal algorithm,</span>
<span class="sd">        it requires distinct ray geometry calculations.</span>

<span class="sd">        The coordinate system is defined with the source rotating around the</span>
<span class="sd">        isocenter, a detector array at a fixed distance from the source, and</span>
<span class="sd">        rays connecting the source to each detector pixel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdd : float</span>
<span class="sd">        The Source-to-Detector Distance (SDD), representing the total</span>
<span class="sd">        distance from the X-ray source to the detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        The Source-to-Isocenter Distance (SID), representing the distance</span>
<span class="sd">        from the X-ray source to the center of rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === FAN BEAM GEOMETRY SETUP ===</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Calculate source and detector positions for current projection angle</span>
    <span class="c1"># Source position: rotated by angle around isocenter at distance sid (SID)</span>
    <span class="n">src_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Source x-coordinate in world space</span>
    <span class="n">src_y</span> <span class="o">=</span>  <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span>  <span class="c1"># Source y-coordinate in world space</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># Detector x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Detector y-coordinate</span>

    <span class="c1"># === RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">dir_y</span><span class="p">)</span>  <span class="c1"># Ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Degenerate ray case</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Normalize ray direction vector for parametric traversal</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">inv_len</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>  <span class="c1"># Volume boundary intersections</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Source outside volume bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>  <span class="c1"># No valid intersection</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL (same algorithm as parallel beam) ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter</span>
    
    <span class="c1"># Convert ray entry point to voxel indices (using source as ray origin)</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="c1"># Traversal parameters (identical to parallel beam implementation)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># Main traversal loop with bilinear interpolation (identical to parallel beam)</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># Bilinear interpolation (identical to parallel beam)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">]</span>     <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>       <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span>
                <span class="p">)</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>
        
        <span class="c1"># Voxel boundary crossing logic (identical to parallel beam)</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_fan_2d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D fan beam</span>
<span class="sd">    backprojection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        As the adjoint to the fan beam forward projection, this operation</span>
<span class="sd">        distributes sinogram values back into the volume along the same ray</span>
<span class="sd">        paths. It employs identical ray-tracing logic but relies on atomic</span>
<span class="sd">        operations to manage concurrent writes from multiple threads.</span>

<span class="sd">        The mathematical foundation involves implementing the transpose of</span>
<span class="sd">        the fan beam forward projection matrix, which distributes detector</span>
<span class="sd">        measurements back along divergent ray paths using bilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdd : float</span>
<span class="sd">        The Source-to-Detector Distance (SDD), representing the total</span>
<span class="sd">        distance from the X-ray source to the detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        The Source-to-Isocenter Distance (SID), representing the distance</span>
<span class="sd">        from the X-ray source to the center of rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === BACKPROJECTION VALUE AND GEOMETRY SETUP ===</span>
    <span class="n">val</span>   <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject along this ray</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Calculate source and detector positions for current projection angle</span>
    <span class="c1"># Source position: rotated by angle around isocenter at distance sid (SID)</span>
    <span class="n">src_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Source x-coordinate in world space</span>
    <span class="n">src_y</span> <span class="o">=</span>  <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span>  <span class="c1"># Source y-coordinate in world space</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># Detector x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Detector y-coordinate</span>

    <span class="c1"># === RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">dir_y</span><span class="p">)</span>  <span class="c1"># Ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># Skip degenerate rays</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>        <span class="c1"># Normalization factor for ray direction</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">inv_len</span>  <span class="c1"># Normalized ray direction vector</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === FAN BEAM BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along divergent ray path using bilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at ray segment midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH BILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA ATOMIC OPERATIONS: Critical for fan beam backprojection thread safety</span>
                <span class="c1"># Fan beam rays converge at source, creating higher probability of voxel write conflicts</span>
                <span class="c1"># Atomic operations prevent race conditions when multiple divergent rays write to same voxel</span>
                <span class="c1"># Performance consideration: Fan beam geometry may have more atomic contention than parallel beam</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>  <span class="c1"># Bottom-left corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>  <span class="c1"># Bottom-right corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>        <span class="c1"># Top-left corner atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>        <span class="c1"># Top-right corner atomic write</span>

        <span class="c1"># === VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 3-D CONE BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cone_3d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_vol</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone-beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 3D cone-beam</span>
<span class="sd">    forward projection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Cone-beam geometry extends the fan-beam configuration to 3D by</span>
<span class="sd">        employing a 2D detector array. Rays originate from a point source</span>
<span class="sd">        and form a cone-shaped beam. This implementation adapts the</span>
<span class="sd">        Siddon-Joseph algorithm to 3D by incorporating trilinear</span>
<span class="sd">        interpolation and 3D voxel traversal.</span>

<span class="sd">        The coordinate system is defined with the source rotating around the</span>
<span class="sd">        isocenter in the xy-plane. The 2D detector, with coordinates (u, v),</span>
<span class="sd">        is positioned at a fixed distance from the source, and the z-axis</span>
<span class="sd">        is oriented vertically.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdd : float</span>
<span class="sd">        The Source-to-Detector Distance (SDD), representing the total</span>
<span class="sd">        distance from the X-ray source to the detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        The Source-to-Isocenter Distance (SID), representing the distance</span>
<span class="sd">        from the X-ray source to the center of rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iview</span> <span class="o">&gt;=</span> <span class="n">n_views</span> <span class="ow">or</span> <span class="n">iu</span> <span class="o">&gt;=</span> <span class="n">n_u</span> <span class="ow">or</span> <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">n_v</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === 3D CONE BEAM GEOMETRY SETUP ===</span>
    <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iview</span><span class="p">],</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iview</span><span class="p">]</span>  <span class="c1"># Projection angle trigonometry</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">iu</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="p">,</span> <span class="p">(</span><span class="n">iv</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dv</span>  <span class="c1"># Detector coordinates (centered)</span>

    <span class="c1"># Calculate 3D source and detector positions</span>
    <span class="c1"># Source rotates in xy-plane around isocenter, z-coordinate is zero</span>
    <span class="n">src_x</span><span class="p">,</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">src_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="mf">0.0</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="c1"># u-coordinate is in-plane offset, v-coordinate is vertical (z-direction)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># In-plane x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># In-plane y-coordinate  </span>
    <span class="n">det_z</span> <span class="o">=</span> <span class="n">v</span>                                           <span class="c1"># Vertical z-coordinate</span>

    <span class="c1"># === 3D RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element in 3D space</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">det_z</span> <span class="o">-</span> <span class="n">src_z</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span><span class="o">*</span><span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">dir_y</span> <span class="o">+</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">dir_z</span><span class="p">)</span>  <span class="c1"># 3D ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Degenerate ray case</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Normalize 3D ray direction vector for parametric traversal</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">dir_x</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">inv_len</span>

    <span class="c1"># === 3D RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with 3D volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Source outside x-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Y-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>  <span class="c1"># Source outside y-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Z-direction boundary intersections (extends 2D algorithm to 3D)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">,</span> <span class="p">(</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cz</span> <span class="ow">or</span> <span class="n">src_z</span> <span class="o">&gt;</span> <span class="n">cz</span><span class="p">:</span>  <span class="c1"># Source outside z-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>  <span class="c1"># No valid 3D intersection</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === 3D SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter</span>
    
    <span class="c1"># Convert 3D ray entry point to voxel indices</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_z</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span><span class="p">))</span>  <span class="c1"># Current voxel z-index</span>

    <span class="c1"># 3D traversal parameters (extends 2D algorithm)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span><span class="p">,</span> <span class="n">step_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per x-voxel</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per y-voxel</span>
    <span class="n">dt_z</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per z-voxel</span>
    
    <span class="c1"># Calculate parameter values for next 3D voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="p">((</span><span class="n">iz</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === 3D TRAVERSAL LOOP WITH TRILINEAR INTERPOLATION ===</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current 3D voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next 3D voxel boundary crossing (minimum of x, y, z boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># === TRILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample 3D volume at ray segment midpoint for accurate integration</span>
                <span class="c1"># Mathematical basis: Midpoint rule for numerical integration along 3D ray segments</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate in volume space</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate in volume space</span>
                <span class="n">mid_z</span> <span class="o">=</span> <span class="n">src_z</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span>  <span class="c1"># Midpoint z-coordinate in volume space</span>
                
                <span class="c1"># Convert continuous 3D coordinates to discrete voxel indices and fractional weights</span>
                <span class="c1"># Floor operation gives base voxel index, fractional part gives interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_z</span><span class="p">))</span>  <span class="c1"># Base voxel indices (corner 0,0,0)</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">mid_z</span> <span class="o">-</span> <span class="n">iz0</span>  <span class="c1"># Fractional parts: distance from base voxel center [0,1]</span>
                
                <span class="c1"># === TRILINEAR INTERPOLATION WEIGHT CALCULATION ===</span>
                <span class="c1"># Mathematical basis: Trilinear interpolation formula f(x,y,z) = Σ f(xi,yi,zi) * wi(x,y,z)</span>
                <span class="c1"># where wi(x,y,z) are the trilinear basis functions for each corner voxel of the 3D cube</span>
                <span class="c1"># Weights are products of 1D linear interpolation weights: (1-dx) or dx, (1-dy) or dy, (1-dz) or dz</span>
                <span class="c1"># Each of the 8 cube corners gets a weight proportional to its distance from the sample point</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span>  <span class="c1"># Corner (0,0,0): weight = product of distances from opposite faces</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span><span class="p">]</span>     <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span>     <span class="c1"># Corner (1,0,0): weight = dx * (1-dy) * (1-dz)</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span>     <span class="c1"># Corner (0,1,0): weight = (1-dx) * dy * (1-dz)</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span> <span class="o">+</span>     <span class="c1"># Corner (0,0,1): weight = (1-dx) * (1-dy) * dz</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span><span class="p">]</span>     <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span>         <span class="c1"># Corner (1,1,0): weight = dx * dy * (1-dz)</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span> <span class="o">+</span>         <span class="c1"># Corner (1,0,1): weight = dx * (1-dy) * dz</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span> <span class="o">+</span>         <span class="c1"># Corner (0,1,1): weight = (1-dx) * dy * dz</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span>               <span class="c1"># Corner (1,1,1): weight = dx * dy * dz</span>
                <span class="p">)</span>
                <span class="c1"># Accumulate contribution weighted by 3D ray segment length (discrete line integral approximation)</span>
                <span class="c1"># This implements the 3D Radon transform: integral of f(x,y,z) along the ray path</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>

        <span class="c1"># === 3D VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first in 3D</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span> <span class="ow">and</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>      <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">elif</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tx</span> <span class="ow">and</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>    <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
        <span class="k">else</span><span class="p">:</span>                          <span class="c1"># Z-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tz</span>
            <span class="n">iz</span> <span class="o">+=</span> <span class="n">step_z</span>
            <span class="n">tz</span> <span class="o">+=</span> <span class="n">dt_z</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cone_3d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
    <span class="n">d_vol</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone-beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 3D cone-beam</span>
<span class="sd">    backprojection.</span>

<span class="sd">    .. note::</span>
<span class="sd">        As the adjoint to the cone-beam forward projection, this operation</span>
<span class="sd">        distributes sinogram values back into the 3D volume along the same</span>
<span class="sd">        ray paths. It uses identical ray-tracing logic but incorporates</span>
<span class="sd">        atomic operations to manage concurrent writes from multiple threads.</span>

<span class="sd">        The mathematical foundation is based on implementing the transpose of</span>
<span class="sd">        the cone-beam forward projection matrix, which distributes detector</span>
<span class="sd">        measurements back along divergent 3D ray paths using trilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sdd : float</span>
<span class="sd">        The Source-to-Detector Distance (SDD), representing the total</span>
<span class="sd">        distance from the X-ray source to the detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        The Source-to-Isocenter Distance (SID), representing the distance</span>
<span class="sd">        from the X-ray source to the center of rotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iview</span> <span class="o">&gt;=</span> <span class="n">n_views</span> <span class="ow">or</span> <span class="n">iu</span> <span class="o">&gt;=</span> <span class="n">n_u</span> <span class="ow">or</span> <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">n_v</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === 3D BACKPROJECTION VALUE AND GEOMETRY SETUP ===</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject along this ray</span>
    <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iview</span><span class="p">],</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iview</span><span class="p">]</span>  <span class="c1"># Projection angle trigonometry</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">iu</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="p">,</span> <span class="p">(</span><span class="n">iv</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dv</span>  <span class="c1"># Detector coordinates (centered)</span>

    <span class="c1"># Calculate 3D source and detector positions</span>
    <span class="c1"># Source rotates in xy-plane around isocenter, z-coordinate is zero</span>
    <span class="n">src_x</span><span class="p">,</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">src_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="mf">0.0</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="c1"># u-coordinate is in-plane offset, v-coordinate is vertical (z-direction)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># In-plane x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># In-plane y-coordinate</span>
    <span class="n">det_z</span> <span class="o">=</span> <span class="n">v</span>                                           <span class="c1"># Vertical z-coordinate</span>

    <span class="c1"># === 3D RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element in 3D space</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">det_z</span> <span class="o">-</span> <span class="n">src_z</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span><span class="o">*</span><span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">dir_y</span> <span class="o">+</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">dir_z</span><span class="p">)</span>  <span class="c1"># 3D ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># Skip degenerate rays</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>        <span class="c1"># Normalization factor for ray direction</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">dir_x</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">inv_len</span>  <span class="c1"># Normalized 3D ray direction vector</span>

    <span class="c1"># === 3D RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with 3D volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>
    
    <span class="c1"># Y-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>
    
    <span class="c1"># Z-direction boundary intersections (extends 2D algorithm to 3D)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">,</span> <span class="p">(</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cz</span> <span class="ow">or</span> <span class="n">src_z</span> <span class="o">&gt;</span> <span class="n">cz</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === 3D SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_z</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span><span class="p">))</span>  <span class="c1"># Current voxel z-index</span>

    <span class="c1"># 3D traversal parameters (extends 2D algorithm)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span><span class="p">,</span> <span class="n">step_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per x-voxel</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per y-voxel</span>
    <span class="n">dt_z</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per z-voxel</span>
    
    <span class="c1"># Calculate parameter values for next 3D voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="p">((</span><span class="n">iz</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === 3D CONE BEAM BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along divergent 3D ray path using trilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current 3D voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next 3D voxel boundary crossing (minimum of x, y, z boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># === TRILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample 3D volume at ray segment midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate</span>
                <span class="n">mid_z</span> <span class="o">=</span> <span class="n">src_z</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span>  <span class="c1"># Midpoint z-coordinate</span>
                
                <span class="c1"># Convert continuous 3D coordinates to voxel indices and interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_z</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">mid_z</span> <span class="o">-</span> <span class="n">iz0</span>  <span class="c1"># Fractional parts for 3D weights</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH TRILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA 3D ATOMIC OPERATIONS: Most complex atomic pattern in cone beam backprojection</span>
                <span class="c1"># 8 atomic writes per ray segment (one per cube corner) increases memory contention significantly</span>
                <span class="c1"># Cone beam geometry creates maximum ray convergence, highest probability of write conflicts</span>
                <span class="c1"># Performance impact: 3D atomics are most expensive due to volume of concurrent writes</span>
                <span class="c1"># Memory bandwidth: 8 atomic operations per interpolation point can saturate memory subsystem</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>  <span class="c1"># Corner (0,0,0) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>      <span class="c1"># Corner (1,0,0) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>      <span class="c1"># Corner (0,1,0) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>      <span class="c1"># Corner (0,0,1) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>          <span class="c1"># Corner (1,1,0) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>          <span class="c1"># Corner (1,0,1) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>          <span class="c1"># Corner (0,1,1) - atomic write</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>              <span class="c1"># Corner (1,1,1) - atomic write</span>

        <span class="c1"># === 3D VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first in 3D</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span> <span class="ow">and</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>      <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">elif</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tx</span> <span class="ow">and</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>    <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
        <span class="k">else</span><span class="p">:</span>                          <span class="c1"># Z-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tz</span>
            <span class="n">iz</span> <span class="o">+=</span> <span class="n">step_z</span>
            <span class="n">tz</span> <span class="o">+=</span> <span class="n">dt_z</span>


<span class="c1"># ############################################################################</span>
<span class="c1"># DIFFERENTIABLE TORCH FUNCTIONS</span>
<span class="c1"># ############################################################################</span>

<div class="viewcode-block" id="ParallelProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 2D parallel beam forward projection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for parallel beam geometry. It implements the Radon transform</span>
<span class="sd">    for parallel beam CT geometry with full gradient support for optimization-based</span>
<span class="sd">    reconstruction algorithms.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes the sinogram (projection data) from a 2D image using</span>
<span class="sd">    parallel beam geometry, where all rays are parallel and perpendicular to the</span>
<span class="sd">    detector array. The backward pass computes gradients using the adjoint backprojection</span>
<span class="sd">    operation, enabling end-to-end differentiable CT reconstruction.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated Siddon-Joseph ray tracing for accurate volume sampling</span>
<span class="sd">        - Bilinear interpolation for smooth gradients and sub-pixel accuracy</span>
<span class="sd">        - Automatic GPU memory management and device consistency</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Optimized thread organization for maximum GPU utilization</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        The parallel beam Radon transform is defined as:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            R[f](s,\\theta) = \\int_{-\\infty}^{\\infty} f(s\\cos\\theta - t\\sin\\theta, s\\sin\\theta + t\\cos\\theta) dt</span>
<span class="sd">        </span>
<span class="sd">        where f(x,y) is the input image, s is the detector coordinate, and θ is the</span>
<span class="sd">        projection angle. This implementation uses the Siddon-Joseph algorithm for</span>
<span class="sd">        discrete approximation of the line integral.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import ParallelProjectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create a 2D image with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define projection parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; num_detectors = 128</span>
<span class="sd">        &gt;&gt;&gt; detector_spacing = 1.0</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute forward projection</span>
<span class="sd">        &gt;&gt;&gt; projector = ParallelProjectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; sinogram = projector(image, angles, num_detectors, detector_spacing)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = sinogram.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Gradient shape: {image.grad.shape}&quot;)  # (128, 128)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        This function requires CUDA-capable hardware and a properly</span>
<span class="sd">        configured CUDA environment. All input tensors must be on the same</span>
<span class="sd">        CUDA device.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ParallelProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 2D parallel beam forward projection (Radon transform) of an image using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : torch.Tensor</span>
<span class="sd">            2D input image tensor of shape (H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `image`.</span>
<span class="sd">        num_detectors : int</span>
<span class="sd">            Number of detector elements in the sinogram (columns).</span>
<span class="sd">        detector_spacing : float, optional</span>
<span class="sd">            Physical spacing between detector elements (default: 1.0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D tensor of shape (num_angles, num_detectors) containing the forward projection (sinogram) on the same device as `image`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sinogram = ParallelProjectorFunction.apply(</span>
<span class="sd">        ...     image, angles, 128, 1.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="c1"># Ensure input is float32 for kernel compatibility</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_image</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">sinogram</span></div>


<div class="viewcode-block" id="ParallelProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction.backward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span>

        <span class="n">grad_image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_img_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_image</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">d_img_grad</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_image</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ParallelBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 2D parallel beam backprojection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for parallel beam backprojection. It implements the adjoint</span>
<span class="sd">    (transpose) of the Radon transform, distributing sinogram values back into the</span>
<span class="sd">    reconstruction volume along the same ray paths used in forward projection.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes a 2D reconstruction from sinogram data using parallel</span>
<span class="sd">    beam backprojection. The backward pass computes gradients using forward projection,</span>
<span class="sd">    enabling end-to-end differentiable CT reconstruction pipelines.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated Siddon-Joseph ray tracing with atomic operations</span>
<span class="sd">        - Bilinear interpolation for smooth gradient flow and sub-pixel accuracy</span>
<span class="sd">        - Thread-safe voxel accumulation using CUDA atomic operations</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Automatic memory management and device consistency</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        The parallel beam backprojection is the adjoint of the Radon transform:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            R^*[p](x,y) = \\int_0^\\pi p(x\\cos\\theta + y\\sin\\theta, \\theta) d\\theta</span>
<span class="sd">        </span>
<span class="sd">        where p(s,θ) is the sinogram data, and R* is the backprojection operator.</span>
<span class="sd">        This operation distributes each projection ray&#39;s value back along its path</span>
<span class="sd">        through the reconstruction volume.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import ParallelBackprojectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create sinogram data with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(180, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define reconstruction parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; detector_spacing = 1.0</span>
<span class="sd">        &gt;&gt;&gt; H, W = 128, 128  # Reconstruction size</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute backprojection</span>
<span class="sd">        &gt;&gt;&gt; backprojector = ParallelBackprojectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; reconstruction = backprojector(sinogram, angles, detector_spacing, H, W)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = reconstruction.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Sinogram gradient shape: {sinogram.grad.shape}&quot;)  # (180, 128)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        This function requires CUDA-capable hardware and a properly</span>
<span class="sd">        configured CUDA environment. All input tensors must be on the same</span>
<span class="sd">        CUDA device.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ParallelBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 2D parallel beam backprojection (adjoint Radon transform) of a sinogram using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D input sinogram tensor of shape (num_angles, num_detectors), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        detector_spacing : float, optional</span>
<span class="sd">            Physical spacing between detector elements (default: 1.0).</span>
<span class="sd">        H : int, optional</span>
<span class="sd">            Height of the output reconstruction image (default: 128).</span>
<span class="sd">        W : int, optional</span>
<span class="sd">            Width of the output reconstruction image (default: 128).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reco : torch.Tensor</span>
<span class="sd">            2D tensor of shape (H, W) containing the reconstructed image on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(180, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; reco = ParallelBackprojectorFunction.apply(</span>
<span class="sd">        ...     sinogram, angles, 1.0, 128, 128</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="c1"># Ensure input is float32 for kernel compatibility</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span>

        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">reco</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">reco</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">reco</span></div>


<div class="viewcode-block" id="ParallelBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="FanProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FanProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 2D fan beam forward projection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for fan beam geometry. Fan beam geometry uses divergent rays</span>
<span class="sd">    emanating from a point X-ray source to a linear detector array, which is common</span>
<span class="sd">    in medical CT scanners and provides faster data acquisition than parallel beam.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes the sinogram from a 2D image using fan beam geometry,</span>
<span class="sd">    where rays diverge from a point source to individual detector elements. The backward</span>
<span class="sd">    pass computes gradients using the adjoint backprojection operation with the same</span>
<span class="sd">    divergent ray geometry.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated Siddon-Joseph ray tracing for divergent beam geometry</span>
<span class="sd">        - Point source to detector ray path calculations with geometric corrections</span>
<span class="sd">        - Bilinear interpolation for smooth gradients and sub-pixel accuracy</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Configurable source and detector distances for flexible geometry setup</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        Fan beam projection involves rays from a point source at distance `sid` (SID)</span>
<span class="sd">        from the isocenter to detector elements at distance `sdd` (SDD) from the source.</span>
<span class="sd">        The magnification factor M = sdd / sid determines the</span>
<span class="sd">        geometric scaling between object and detector coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Each ray connects the source position (rotated around isocenter) to a specific</span>
<span class="sd">        detector element, creating a divergent beam pattern that covers the field of view.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import FanProjectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create a 2D image with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define fan beam geometry parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; num_detectors = 512</span>
<span class="sd">        &gt;&gt;&gt; detector_spacing = 1.0</span>
<span class="sd">        &gt;&gt;&gt; source_distance = 1000.0    # Distance from source to isocenter</span>
<span class="sd">        &gt;&gt;&gt; detector_distance = 1500.0  # Distance from source to detector</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute forward projection</span>
<span class="sd">        &gt;&gt;&gt; projector = FanProjectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; sinogram = projector(image, angles, num_detectors, detector_spacing,</span>
<span class="sd">        ...                     source_distance, detector_distance)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = sinogram.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Gradient shape: {image.grad.shape}&quot;)  # (256, 256)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        Fan beam geometry requires 360° angular sampling (2π radians) for</span>
<span class="sd">        complete reconstruction, unlike parallel beam, which only needs</span>
<span class="sd">        180°. The source distance should be significantly larger than the</span>
<span class="sd">        object size to minimize geometric distortions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FanProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 2D fan beam forward projection of an image using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : torch.Tensor</span>
<span class="sd">            2D input image tensor of shape (H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `image`.</span>
<span class="sd">        num_detectors : int</span>
<span class="sd">            Number of detector elements in the sinogram (columns).</span>
<span class="sd">        detector_spacing : float</span>
<span class="sd">            Physical spacing between detector elements.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D tensor of shape (num_angles, num_detectors) containing the fan beam sinogram on the same device as `image`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Fan beam geometry uses divergent rays from a point source to the detector.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sinogram = FanProjectorFunction.apply(</span>
<span class="sd">        ...     image, angles, 512, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_ang</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_image</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sinogram</span></div>


<div class="viewcode-block" id="FanProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">n_det</span><span class="p">,</span> <span class="n">det_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span>

        <span class="n">grad_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_img_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_img</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_img_grad</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">det_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_img</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="FanBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FanBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 2D fan beam backprojection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for fan beam backprojection. It implements the adjoint of the</span>
<span class="sd">    fan beam projection operator, distributing sinogram values back into the reconstruction</span>
<span class="sd">    volume along divergent ray paths from point source to detector elements.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes a 2D reconstruction from fan beam sinogram data using</span>
<span class="sd">    backprojection with divergent ray geometry. The backward pass computes gradients</span>
<span class="sd">    using fan beam forward projection, enabling end-to-end differentiable CT reconstruction.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated Siddon-Joseph ray tracing with divergent beam geometry</span>
<span class="sd">        - Point source to detector ray path calculations with geometric corrections</span>
<span class="sd">        - Thread-safe voxel accumulation using CUDA atomic operations</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Configurable source and detector distances for flexible geometry setup</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        Fan beam backprojection distributes each detector measurement back along its</span>
<span class="sd">        corresponding divergent ray path. The ray geometry is determined by the source</span>
<span class="sd">        position (rotating around isocenter) and the detector element position, creating</span>
<span class="sd">        a divergent pattern that reconstructs the object with geometric magnification.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import FanBackprojectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create fan beam sinogram data with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(360, 512, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define reconstruction parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; detector_spacing = 1.0</span>
<span class="sd">        &gt;&gt;&gt; H, W = 256, 256  # Reconstruction size</span>
<span class="sd">        &gt;&gt;&gt; sdd = 1500.0  # Source-to-Detector Distance</span>
<span class="sd">        &gt;&gt;&gt; sid = 1000.0  # Source-to-Isocenter Distance</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute backprojection</span>
<span class="sd">        &gt;&gt;&gt; backprojector = FanBackprojectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; reconstruction = backprojector(sinogram, angles, detector_spacing, H, W,</span>
<span class="sd">        ...                               sdd, sid)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = reconstruction.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Sinogram gradient shape: {sinogram.grad.shape}&quot;)  # (360, 512)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        Fan beam backprojection requires careful handling of ray convergence</span>
<span class="sd">        at the source, which can lead to higher atomic contention in CUDA</span>
<span class="sd">        kernels compared to parallel beam. The geometry parameters must</span>
<span class="sd">        match those used in the forward projection for consistency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FanBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 2D fan beam backprojection of a sinogram using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D input fan beam sinogram tensor of shape (num_angles, num_detectors), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        detector_spacing : float</span>
<span class="sd">            Physical spacing between detector elements.</span>
<span class="sd">        H : int</span>
<span class="sd">            Height of the output reconstruction image.</span>
<span class="sd">        W : int</span>
<span class="sd">            Width of the output reconstruction image.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reco : torch.Tensor</span>
<span class="sd">            2D tensor of shape (H, W) containing the reconstructed image on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Fan beam geometry uses divergent rays from a point source to the detector.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(360, 512, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; reco = FanBackprojectorFunction.apply(</span>
<span class="sd">        ...     sinogram, angles, 1.0, 256, 256, 1000.0, 500.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span>

        <span class="n">reco</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">reco</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reco</span></div>


<div class="viewcode-block" id="FanBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">det_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">det_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ConeProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConeProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 3D cone beam forward projection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for 3D cone beam geometry. Cone beam geometry uses a point X-ray</span>
<span class="sd">    source and 2D detector array to capture volumetric projection data in a single circular</span>
<span class="sd">    scan, enabling full 3D CT reconstruction from one acquisition.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes 3D projection data from a volume using cone beam geometry,</span>
<span class="sd">    where rays emanate from a point source to each pixel of a 2D detector array. The</span>
<span class="sd">    backward pass computes gradients using 3D adjoint backprojection, enabling end-to-end</span>
<span class="sd">    differentiable volumetric CT reconstruction.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated 3D Siddon-Joseph ray tracing with trilinear interpolation</span>
<span class="sd">        - Point source to 2D detector array ray path calculations</span>
<span class="sd">        - Optimized 3D thread organization for maximum GPU utilization</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Configurable detector array size and spacing for flexible geometry</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        3D cone beam projection involves rays from a point source to each detector pixel</span>
<span class="sd">        (u,v) on a 2D detector array. The source rotates around the isocenter in the xy-plane</span>
<span class="sd">        while the detector maintains fixed distance from the source. Each ray samples the</span>
<span class="sd">        3D volume using trilinear interpolation for accurate gradient computation.</span>
<span class="sd">        </span>
<span class="sd">        The cone angle should be kept small (&lt; 30°) to minimize cone beam artifacts in</span>
<span class="sd">        reconstruction. For larger volumes, helical scanning may be required.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import ConeProjectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create a 3D volume with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; volume = torch.randn(128, 128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define cone beam geometry parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; det_u, det_v = 256, 256  # 2D detector array size</span>
<span class="sd">        &gt;&gt;&gt; du, dv = 1.0, 1.0       # Detector pixel spacing</span>
<span class="sd">        &gt;&gt;&gt; sdd = 1500.0    # Source-to-Detector Distance</span>
<span class="sd">        &gt;&gt;&gt; sid = 1000.0  # Source-to-Isocenter Distance</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute 3D forward projection</span>
<span class="sd">        &gt;&gt;&gt; projector = ConeProjectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; projections = projector(volume, angles, det_u, det_v, du, dv,</span>
<span class="sd">        ...                        sdd, sid)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = projections.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Volume gradient shape: {volume.grad.shape}&quot;)  # (128, 128, 128)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        3D cone-beam projection is computationally intensive and requires</span>
<span class="sd">        significant GPU memory. For large-scale applications, consider</span>
<span class="sd">        using smaller volumes or gradient checkpointing. The cone angle</span>
<span class="sd">        should be minimized to reduce reconstruction artifacts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ConeProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 3D cone beam forward projection of a volume using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        volume : torch.Tensor</span>
<span class="sd">            3D input volume tensor of shape (D, H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_views,), must be on the same CUDA device as `volume`.</span>
<span class="sd">        det_u : int</span>
<span class="sd">            Number of detector elements along the u-axis (width).</span>
<span class="sd">        det_v : int</span>
<span class="sd">            Number of detector elements along the v-axis (height).</span>
<span class="sd">        du : float</span>
<span class="sd">            Physical spacing between detector elements along the u-axis.</span>
<span class="sd">        dv : float</span>
<span class="sd">            Physical spacing between detector elements along the v-axis.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sino : torch.Tensor</span>
<span class="sd">            3D tensor of shape (num_views, det_u, det_v) containing the cone beam projections on the same device as `volume`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Cone beam geometry uses a point source and a 2D detector array.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate 3D ray tracing and trilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; volume = torch.randn(128, 128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sino = ConeProjectorFunction.apply(</span>
<span class="sd">        ...     volume, angles, 256, 256, 1.0, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_vol</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_cone_3d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_vol</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sino</span></div>


<div class="viewcode-block" id="ConeProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
         <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">grad_vol</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_vol_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_vol</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_cone_3d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">d_vol_grad</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_vol</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ConeBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConeBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PyTorch autograd function for differentiable 3D cone beam backprojection.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for 3D cone beam backprojection. It implements the adjoint of the</span>
<span class="sd">    3D cone beam projection operator, distributing projection values from a 2D detector array</span>
<span class="sd">    back into a 3D reconstruction volume along divergent ray paths.</span>
<span class="sd">    </span>
<span class="sd">    The forward pass computes a 3D reconstruction from cone beam projection data using</span>
<span class="sd">    backprojection with 3D divergent ray geometry. The backward pass computes gradients</span>
<span class="sd">    using 3D cone beam forward projection, enabling end-to-end differentiable volumetric</span>
<span class="sd">    CT reconstruction pipelines.</span>
<span class="sd">    </span>
<span class="sd">    Key Features:</span>
<span class="sd">        - CUDA-accelerated 3D Siddon-Joseph ray tracing with trilinear interpolation</span>
<span class="sd">        - Point source to 2D detector array ray path calculations in 3D space</span>
<span class="sd">        - Thread-safe 3D voxel accumulation using CUDA atomic operations</span>
<span class="sd">        - Full PyTorch autograd integration for gradient-based optimization</span>
<span class="sd">        - Optimized 3D memory access patterns and thread organization</span>
<span class="sd">    </span>
<span class="sd">    Mathematical Background:</span>
<span class="sd">        3D cone beam backprojection distributes each detector pixel measurement back along</span>
<span class="sd">        its corresponding 3D ray path from source to detector. The reconstruction process</span>
<span class="sd">        involves trilinear interpolation for sub-voxel accuracy and atomic operations for</span>
<span class="sd">        thread-safe accumulation when multiple rays contribute to the same voxel.</span>
<span class="sd">        </span>
<span class="sd">        Due to the 3D nature and ray convergence, this operation has the highest computational</span>
<span class="sd">        complexity and memory requirements among all projection operators in DiffCT.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from diffct.differentiable import ConeBackprojectorFunction</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create 3D cone beam projection data with gradient tracking</span>
<span class="sd">        &gt;&gt;&gt; projections = torch.randn(360, 256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Define reconstruction parameters</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; D, H, W = 128, 128, 128  # 3D reconstruction size</span>
<span class="sd">        &gt;&gt;&gt; du, dv = 1.0, 1.0       # Detector pixel spacing</span>
<span class="sd">        &gt;&gt;&gt; sdd = 1500.0</span>
<span class="sd">        &gt;&gt;&gt; sid = 1000.0</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute 3D backprojection</span>
<span class="sd">        &gt;&gt;&gt; backprojector = ConeBackprojectorFunction.apply</span>
<span class="sd">        &gt;&gt;&gt; volume = backprojector(projections, angles, D, H, W, du, dv,</span>
<span class="sd">        ...                       sdd, sid)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">        &gt;&gt;&gt; loss = volume.sum()</span>
<span class="sd">        &gt;&gt;&gt; loss.backward()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Projection gradient shape: {projections.grad.shape}&quot;)  # (360, 256, 256)</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        3D cone-beam backprojection is the most memory- and computationally</span>
<span class="sd">        intensive operation in ``diffct``. For large-scale applications,</span>
<span class="sd">        consider using gradient checkpointing, smaller volumes, or</span>
<span class="sd">        distributed computing. Ensure sufficient GPU memory is available.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ConeBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the 3D cone beam backprojection of a projection sinogram using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            3D input cone beam projection tensor of shape (num_views, det_u, det_v), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_views,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        D : int</span>
<span class="sd">            Depth (z-dimension) of the output reconstruction volume.</span>
<span class="sd">        H : int</span>
<span class="sd">            Height (y-dimension) of the output reconstruction volume.</span>
<span class="sd">        W : int</span>
<span class="sd">            Width (x-dimension) of the output reconstruction volume.</span>
<span class="sd">        du : float</span>
<span class="sd">            Physical spacing between detector elements along the u-axis.</span>
<span class="sd">        dv : float</span>
<span class="sd">            Physical spacing between detector elements along the v-axis.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol : torch.Tensor</span>
<span class="sd">            3D tensor of shape (D, H, W) containing the reconstructed volume on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Cone beam geometry uses a point source and a 2D detector array.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate 3D ray tracing and trilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; projections = torch.randn(360, 256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; vol = ConeBackprojectorFunction.apply(</span>
<span class="sd">        ...     projections, angles, 128, 128, 128, 1.0, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">vol</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_cone_3d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vol</span></div>


<div class="viewcode-block" id="ConeBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
         <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">H</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_cone_3d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Yipeng Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>