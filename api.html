

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; diffct  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Getting Started" href="getting_started.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            diffct
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallel-beam-operators">Parallel Beam Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction"><code class="docutils literal notranslate"><span class="pre">ParallelProjectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">ParallelProjectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">ParallelProjectorFunction.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction"><code class="docutils literal notranslate"><span class="pre">ParallelBackprojectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">ParallelBackprojectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">ParallelBackprojectorFunction.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fan-beam-operators">Fan Beam Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.FanProjectorFunction"><code class="docutils literal notranslate"><span class="pre">FanProjectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">FanProjectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">FanProjectorFunction.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction"><code class="docutils literal notranslate"><span class="pre">FanBackprojectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">FanBackprojectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">FanBackprojectorFunction.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cone-beam-operators">Cone Beam Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction"><code class="docutils literal notranslate"><span class="pre">ConeProjectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">ConeProjectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">ConeProjectorFunction.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction"><code class="docutils literal notranslate"><span class="pre">ConeBackprojectorFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.backward"><code class="docutils literal notranslate"><span class="pre">ConeBackprojectorFunction.backward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.forward"><code class="docutils literal notranslate"><span class="pre">ConeBackprojectorFunction.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage-notes">Usage Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">diffct</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Link to this heading"></a></h1>
<p>This section provides comprehensive documentation for all differentiable CT operators in <cite>diffct</cite>. Each function is implemented as a PyTorch autograd Function, enabling seamless gradient computation through the CT reconstruction pipeline.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>The <cite>diffct</cite> library provides six main differentiable operators organized by geometry type:</p>
<ul class="simple">
<li><p><strong>Parallel Beam (2D):</strong> Traditional parallel-beam CT geometry</p></li>
<li><p><strong>Fan Beam (2D):</strong> Fan-beam geometry with configurable source-detector setup</p></li>
<li><p><strong>Cone Beam (3D):</strong> Full 3D cone-beam geometry for volumetric reconstruction</p></li>
</ul>
<p>Each geometry type includes both forward projection and backprojection operators that are fully differentiable and CUDA-accelerated.</p>
</section>
<section id="parallel-beam-operators">
<h2>Parallel Beam Operators<a class="headerlink" href="#parallel-beam-operators" title="Link to this heading"></a></h2>
<p>The parallel beam geometry assumes parallel X-ray beams, commonly used in synchrotron CT and some medical CT scanners.</p>
<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelProjectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">ParallelProjectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelProjectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelProjectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 2D parallel beam forward projection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for parallel beam geometry. It implements the Radon transform
for parallel beam CT geometry with full gradient support for optimization-based
reconstruction algorithms.</p>
<p>The forward pass computes the sinogram (projection data) from a 2D image using
parallel beam geometry, where all rays are parallel and perpendicular to the
detector array. The backward pass computes gradients using the adjoint backprojection
operation, enabling end-to-end differentiable CT reconstruction.</p>
<dl>
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated Siddon-Joseph ray tracing for accurate volume sampling</p></li>
<li><p>Bilinear interpolation for smooth gradients and sub-pixel accuracy</p></li>
<li><p>Automatic GPU memory management and device consistency</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Optimized thread organization for maximum GPU utilization</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>The parallel beam Radon transform is defined as:</p>
<div class="math notranslate nohighlight">
\[R[f](s,\theta) = \int_{-\infty}^{\infty} f(s\cos\theta - t\sin\theta, s\sin\theta + t\cos\theta) dt\]</div>
<p>where f(x,y) is the input image, s is the detector coordinate, and θ is the
projection angle. This implementation uses the Siddon-Joseph algorithm for
discrete approximation of the line integral.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParallelProjectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a 2D image with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define projection parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_detectors</span> <span class="o">=</span> <span class="mi">128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_spacing</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute forward projection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projector</span> <span class="o">=</span> <span class="n">ParallelProjectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sinogram</span> <span class="o">=</span> <span class="n">projector</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradient shape: </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (128, 128)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires CUDA-capable hardware and properly configured CUDA
environment. All input tensors must be on the same CUDA device.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code> (torch.Tensor): Input 2D image tensor of shape (H, W)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_detectors</span></code> (int): Number of detector elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">detector_spacing</span></code> (float): Spacing between detector elements</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Output sinogram of shape (num_angles, num_detectors)</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sinogram</span> <span class="o">=</span> <span class="n">ParallelProjectorFunction</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mf">1.0</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelProjectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_sinogram</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelProjectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelProjectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.forward" title="diffct.differentiable.ParallelProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.forward" title="diffct.differentiable.ParallelProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.backward" title="diffct.differentiable.ParallelProjectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.ParallelProjectorFunction.forward" title="diffct.differentiable.ParallelProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelProjectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_detectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelProjectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelProjectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute parallel beam forward projection (Radon transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – Input 2D image tensor of shape (H, W). Must be on CUDA device
and have dtype float32 or float64. Represents the object to be projected.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_angles,). Must be on
same CUDA device as image. Typically torch.linspace(0, π, n_angles) for
parallel beam geometry.</p></li>
<li><p><strong>num_detectors</strong> (<em>int</em>) – Number of detector elements in the linear detector array.
Should be &gt;= image diagonal for complete coverage. Typical values: 128-2048.</p></li>
<li><p><strong>detector_spacing</strong> (<em>float</em><em>, </em><em>optional</em>) – Physical spacing between detector elements
in mm or other length units. Determines the field of view and spatial
resolution. Default: 1.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Sinogram tensor of shape (n_angles, num_detectors) containing</dt><dd><p>the projection data. Each row corresponds to one projection angle, each
column to one detector element. Values represent line integrals through
the input image.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If input dimensions are incompatible or parameters are invalid</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is typically not called directly. Use ParallelProjectorFunction.apply()
instead for proper autograd integration.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelBackprojectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">ParallelBackprojectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelBackprojectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelBackprojectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 2D parallel beam backprojection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for parallel beam backprojection. It implements the adjoint
(transpose) of the Radon transform, distributing sinogram values back into the
reconstruction volume along the same ray paths used in forward projection.</p>
<p>The forward pass computes a 2D reconstruction from sinogram data using parallel
beam backprojection. The backward pass computes gradients using forward projection,
enabling end-to-end differentiable CT reconstruction pipelines.</p>
<dl>
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated Siddon-Joseph ray tracing with atomic operations</p></li>
<li><p>Bilinear interpolation for smooth gradient flow and sub-pixel accuracy</p></li>
<li><p>Thread-safe voxel accumulation using CUDA atomic operations</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Automatic memory management and device consistency</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>The parallel beam backprojection is the adjoint of the Radon transform:</p>
<div class="math notranslate nohighlight">
\[R^*[p](x,y) = \int_0^\pi p(x\cos\theta + y\sin\theta, \theta) d\theta\]</div>
<p>where p(s,θ) is the sinogram data, and R* is the backprojection operator.
This operation distributes each projection ray’s value back along its path
through the reconstruction volume.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParallelBackprojectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create sinogram data with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define reconstruction parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_spacing</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span>  <span class="c1"># Reconstruction size</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute backprojection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">backprojector</span> <span class="o">=</span> <span class="n">ParallelBackprojectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reconstruction</span> <span class="o">=</span> <span class="n">backprojector</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sinogram gradient shape: </span><span class="si">{</span><span class="n">sinogram</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (180, 128)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function requires CUDA-capable hardware and properly configured CUDA
environment. All input tensors must be on the same CUDA device.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Input sinogram of shape (num_angles, num_detectors)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">detector_spacing</span></code> (float): Spacing between detector elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_width</span></code> (int): Width of output image</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_height</span></code> (int): Height of output image</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code> (torch.Tensor): Reconstructed image of shape (image_height, image_width)</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelBackprojectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelBackprojectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelBackprojectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.forward" title="diffct.differentiable.ParallelBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.forward" title="diffct.differentiable.ParallelBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.backward" title="diffct.differentiable.ParallelBackprojectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.ParallelBackprojectorFunction.forward" title="diffct.differentiable.ParallelBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ParallelBackprojectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ParallelBackprojectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ParallelBackprojectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute parallel beam backprojection (adjoint Radon transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>sinogram</strong> (<em>torch.Tensor</em>) – Input sinogram tensor of shape (n_angles, num_detectors).
Must be on CUDA device. Contains projection data where each row corresponds
to one projection angle and each column to one detector element.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_angles,). Must be on
same CUDA device as sinogram. Should match the angles used for forward projection.</p></li>
<li><p><strong>detector_spacing</strong> (<em>float</em><em>, </em><em>optional</em>) – Physical spacing between detector elements
in mm or other length units. Must match the spacing used in forward projection.
Default: 1.0.</p></li>
<li><p><strong>H</strong> (<em>int</em><em>, </em><em>optional</em>) – Height of the reconstruction volume in pixels. Default: 128.</p></li>
<li><p><strong>W</strong> (<em>int</em><em>, </em><em>optional</em>) – Width of the reconstruction volume in pixels. Default: 128.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Reconstructed 2D image tensor of shape (H, W). Values represent</dt><dd><p>the backprojected reconstruction, which is the adjoint operation of forward
projection. For filtered backprojection, additional filtering is required.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If input dimensions are incompatible or parameters are invalid</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is typically not called directly. Use ParallelBackprojectorFunction.apply()
instead for proper autograd integration.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="fan-beam-operators">
<h2>Fan Beam Operators<a class="headerlink" href="#fan-beam-operators" title="Link to this heading"></a></h2>
<p>Fan beam geometry uses a point X-ray source with a fan-shaped beam, typical in medical CT scanners.</p>
<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.FanProjectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">FanProjectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanProjectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanProjectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 2D fan beam forward projection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for fan beam geometry. Fan beam geometry uses divergent rays
emanating from a point X-ray source to a linear detector array, which is common
in medical CT scanners and provides faster data acquisition than parallel beam.</p>
<p>The forward pass computes the sinogram from a 2D image using fan beam geometry,
where rays diverge from a point source to individual detector elements. The backward
pass computes gradients using the adjoint backprojection operation with the same
divergent ray geometry.</p>
<dl>
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated Siddon-Joseph ray tracing for divergent beam geometry</p></li>
<li><p>Point source to detector ray path calculations with geometric corrections</p></li>
<li><p>Bilinear interpolation for smooth gradients and sub-pixel accuracy</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Configurable source and detector distances for flexible geometry setup</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>Fan beam projection involves rays from a point source at distance <cite>source_distance</cite>
from the isocenter to detector elements at distance <cite>detector_distance</cite> from the source.
The magnification factor M = detector_distance / source_distance determines the
geometric scaling between object and detector coordinates.</p>
<p>Each ray connects the source position (rotated around isocenter) to a specific
detector element, creating a divergent beam pattern that covers the field of view.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">FanProjectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a 2D image with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define fan beam geometry parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_detectors</span> <span class="o">=</span> <span class="mi">512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_spacing</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_distance</span> <span class="o">=</span> <span class="mf">1000.0</span>    <span class="c1"># Distance from source to isocenter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_distance</span> <span class="o">=</span> <span class="mf">1500.0</span>  <span class="c1"># Distance from source to detector</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute forward projection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projector</span> <span class="o">=</span> <span class="n">FanProjectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sinogram</span> <span class="o">=</span> <span class="n">projector</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">source_distance</span><span class="p">,</span> <span class="n">detector_distance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradient shape: </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (256, 256)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fan beam geometry requires 360° angular sampling (2π radians) for complete
reconstruction, unlike parallel beam which only needs 180°. The source distance
should be much larger than the object size to minimize geometric distortions.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code> (torch.Tensor): Input 2D image tensor of shape (H, W)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_detectors</span></code> (int): Number of detector elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">detector_spacing</span></code> (float): Spacing between detector elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source_distance</span></code> (float): Distance from rotation center to X-ray source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isocenter_distance</span></code> (float): Distance from rotation center to detector</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Output sinogram of shape (num_angles, num_detectors)</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.FanProjectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_sinogram</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanProjectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanProjectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.forward" title="diffct.differentiable.FanProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.forward" title="diffct.differentiable.FanProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.backward" title="diffct.differentiable.FanProjectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.FanProjectorFunction.forward" title="diffct.differentiable.FanProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.FanProjectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_detectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isocenter_distance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanProjectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanProjectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute fan beam forward projection with divergent ray geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – Input 2D image tensor of shape (H, W). Must be on CUDA device
and represent the object to be projected using fan beam geometry.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_angles,). Must be on
same CUDA device as image. Typically torch.linspace(0, 2π, n_angles) for
complete fan beam sampling.</p></li>
<li><p><strong>num_detectors</strong> (<em>int</em>) – Number of detector elements in the linear detector array.
Should provide adequate coverage of the magnified object. Typical values: 256-1024.</p></li>
<li><p><strong>detector_spacing</strong> (<em>float</em>) – Physical spacing between detector elements in mm or other
length units. Determines the detector field of view and spatial resolution.</p></li>
<li><p><strong>source_distance</strong> (<em>float</em>) – Distance from X-ray source to isocenter (rotation center)
in mm or other length units. Should be &gt;&gt; object size for good approximation.</p></li>
<li><p><strong>isocenter_distance</strong> (<em>float</em>) – Distance from isocenter to detector array in mm or other
length units. Total source-to-detector distance = source_distance + isocenter_distance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Sinogram tensor of shape (n_angles, num_detectors) containing</dt><dd><p>the fan beam projection data. Each row corresponds to one projection angle,
each column to one detector element. Values represent line integrals along
divergent ray paths.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If geometry parameters are invalid (e.g., negative distances)</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The magnification factor M = (source_distance + isocenter_distance) / source_distance
determines the geometric scaling. Larger source distances reduce magnification and
geometric distortions but may require larger detector arrays for coverage.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.FanBackprojectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">FanBackprojectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanBackprojectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanBackprojectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 2D fan beam backprojection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for fan beam backprojection. It implements the adjoint of the
fan beam projection operator, distributing sinogram values back into the reconstruction
volume along divergent ray paths from point source to detector elements.</p>
<p>The forward pass computes a 2D reconstruction from fan beam sinogram data using
backprojection with divergent ray geometry. The backward pass computes gradients
using fan beam forward projection, enabling end-to-end differentiable CT reconstruction.</p>
<dl class="simple">
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated Siddon-Joseph ray tracing with divergent beam geometry</p></li>
<li><p>Point source to detector ray path calculations with geometric corrections</p></li>
<li><p>Thread-safe voxel accumulation using CUDA atomic operations</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Configurable source and detector distances for flexible geometry setup</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>Fan beam backprojection distributes each detector measurement back along its
corresponding divergent ray path. The ray geometry is determined by the source
position (rotating around isocenter) and the detector element position, creating
a divergent pattern that reconstructs the object with geometric magnification.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">FanBackprojectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create fan beam sinogram data with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define reconstruction parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_spacing</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span>  <span class="c1"># Reconstruction size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_distance</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isocenter_distance</span> <span class="o">=</span> <span class="mf">500.0</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute backprojection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">backprojector</span> <span class="o">=</span> <span class="n">FanBackprojectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reconstruction</span> <span class="o">=</span> <span class="n">backprojector</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">source_distance</span><span class="p">,</span> <span class="n">isocenter_distance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sinogram gradient shape: </span><span class="si">{</span><span class="n">sinogram</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (360, 512)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fan beam backprojection requires careful handling of ray convergence at the source,
which can lead to higher atomic contention in CUDA kernels compared to parallel beam.
The geometry parameters must match those used in forward projection for consistency.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Input sinogram of shape (num_angles, num_detectors)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">detector_spacing</span></code> (float): Spacing between detector elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_width</span></code> (int): Width of output image</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image_height</span></code> (int): Height of output image</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source_distance</span></code> (float): Distance from rotation center to X-ray source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isocenter_distance</span></code> (float): Distance from rotation center to detector</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code> (torch.Tensor): Reconstructed image of shape (image_height, image_width)</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.FanBackprojectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanBackprojectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanBackprojectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.forward" title="diffct.differentiable.FanBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.forward" title="diffct.differentiable.FanBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.backward" title="diffct.differentiable.FanBackprojectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.FanBackprojectorFunction.forward" title="diffct.differentiable.FanBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.FanBackprojectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isocenter_distance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#FanBackprojectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.FanBackprojectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute fan beam backprojection with divergent ray geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>sinogram</strong> (<em>torch.Tensor</em>) – Input sinogram tensor of shape (n_angles, num_detectors).
Must be on CUDA device. Contains fan beam projection data where each row
corresponds to one projection angle and each column to one detector element.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_angles,). Must be on
same CUDA device as sinogram. Should match angles used in forward projection.</p></li>
<li><p><strong>detector_spacing</strong> (<em>float</em>) – Physical spacing between detector elements in mm or other
length units. Must match the spacing used in forward projection.</p></li>
<li><p><strong>H</strong> (<em>int</em>) – Height of the reconstruction volume in pixels.</p></li>
<li><p><strong>W</strong> (<em>int</em>) – Width of the reconstruction volume in pixels.</p></li>
<li><p><strong>source_distance</strong> (<em>float</em>) – Distance from X-ray source to isocenter in mm or other
length units. Must match the value used in forward projection.</p></li>
<li><p><strong>isocenter_distance</strong> (<em>float</em>) – Distance from isocenter to detector array in mm or other
length units. Must match the value used in forward projection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Reconstructed 2D image tensor of shape (H, W). Values represent</dt><dd><p>the fan beam backprojected reconstruction with geometric magnification effects.
For filtered backprojection, additional ramp filtering is required.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If geometry parameters are invalid or inconsistent with sinogram shape</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reconstruction will have geometric magnification determined by the ratio
(source_distance + isocenter_distance) / source_distance. Ensure geometry
parameters are consistent with the forward projection for accurate reconstruction.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="cone-beam-operators">
<h2>Cone Beam Operators<a class="headerlink" href="#cone-beam-operators" title="Link to this heading"></a></h2>
<p>Cone beam geometry extends fan beam to 3D with a cone-shaped X-ray beam for volumetric reconstruction.</p>
<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.ConeProjectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">ConeProjectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeProjectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeProjectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 3D cone beam forward projection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for 3D cone beam geometry. Cone beam geometry uses a point X-ray
source and 2D detector array to capture volumetric projection data in a single circular
scan, enabling full 3D CT reconstruction from one acquisition.</p>
<p>The forward pass computes 3D projection data from a volume using cone beam geometry,
where rays emanate from a point source to each pixel of a 2D detector array. The
backward pass computes gradients using 3D adjoint backprojection, enabling end-to-end
differentiable volumetric CT reconstruction.</p>
<dl>
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated 3D Siddon-Joseph ray tracing with trilinear interpolation</p></li>
<li><p>Point source to 2D detector array ray path calculations</p></li>
<li><p>Optimized 3D thread organization for maximum GPU utilization</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Configurable detector array size and spacing for flexible geometry</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>3D cone beam projection involves rays from a point source to each detector pixel
(u,v) on a 2D detector array. The source rotates around the isocenter in the xy-plane
while the detector maintains fixed distance from the source. Each ray samples the
3D volume using trilinear interpolation for accurate gradient computation.</p>
<p>The cone angle should be kept small (&lt; 30°) to minimize cone beam artifacts in
reconstruction. For larger volumes, helical scanning may be required.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConeProjectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a 3D volume with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define cone beam geometry parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span>  <span class="c1"># 2D detector array size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span>       <span class="c1"># Detector pixel spacing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_distance</span> <span class="o">=</span> <span class="mf">1000.0</span>    <span class="c1"># Source to isocenter distance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isocenter_distance</span> <span class="o">=</span> <span class="mf">500.0</span>  <span class="c1"># Isocenter to detector distance</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute 3D forward projection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projector</span> <span class="o">=</span> <span class="n">ConeProjectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projections</span> <span class="o">=</span> <span class="n">projector</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">source_distance</span><span class="p">,</span> <span class="n">isocenter_distance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">projections</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Volume gradient shape: </span><span class="si">{</span><span class="n">volume</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (128, 128, 128)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>3D cone beam projection is computationally intensive and requires significant GPU
memory. Consider using smaller volumes or gradient checkpointing for large-scale
applications. The cone angle should be minimized to reduce reconstruction artifacts.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">volume</span></code> (torch.Tensor): Input 3D volume tensor of shape (D, H, W)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">det_u</span></code> (int): Number of detector elements in U direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">det_v</span></code> (int): Number of detector elements in V direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">du</span></code> (float): Detector spacing in U direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dv</span></code> (float): Detector spacing in V direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source_distance</span></code> (float): Distance from rotation center to X-ray source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isocenter_distance</span></code> (float): Distance from rotation center to detector</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Output sinogram of shape (num_angles, det_u, det_v)</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ConeProjectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_sinogram</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeProjectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeProjectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.forward" title="diffct.differentiable.ConeProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.forward" title="diffct.differentiable.ConeProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.backward" title="diffct.differentiable.ConeProjectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.ConeProjectorFunction.forward" title="diffct.differentiable.ConeProjectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ConeProjectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">du</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isocenter_distance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeProjectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeProjectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute 3D cone beam forward projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>volume</strong> (<em>torch.Tensor</em>) – Input 3D volume tensor of shape (D, H, W). Must be on CUDA
device and represent the 3D object to be projected using cone beam geometry.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_views,). Must be on
same CUDA device as volume. Typically torch.linspace(0, 2π, n_views) for
complete cone beam sampling.</p></li>
<li><p><strong>det_u</strong> (<em>int</em>) – Number of detector pixels in u-direction (horizontal). Determines
the horizontal field of view. Typical values: 256-2048.</p></li>
<li><p><strong>det_v</strong> (<em>int</em>) – Number of detector pixels in v-direction (vertical). Determines
the vertical field of view and axial coverage. Typical values: 256-2048.</p></li>
<li><p><strong>du</strong> (<em>float</em>) – Physical spacing between detector pixels in u-direction in mm or other
length units. Determines horizontal spatial resolution.</p></li>
<li><p><strong>dv</strong> (<em>float</em>) – Physical spacing between detector pixels in v-direction in mm or other
length units. Determines vertical spatial resolution.</p></li>
<li><p><strong>source_distance</strong> (<em>float</em>) – Distance from X-ray source to isocenter in mm or other
length units. Should be &gt;&gt; volume size for good approximation.</p></li>
<li><p><strong>isocenter_distance</strong> (<em>float</em>) – Distance from isocenter to detector array in mm or other
length units. Total source-to-detector distance = source_distance + isocenter_distance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>3D projection tensor of shape (n_views, det_u, det_v) containing</dt><dd><p>the cone beam projection data. Each 2D slice corresponds to one projection
view, with (u,v) coordinates representing the 2D detector array. Values
represent line integrals along 3D ray paths.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If geometry parameters are invalid or detector size is incompatible</p></li>
<li><p><strong>MemoryError</strong> – If volume or detector array is too large for available GPU memory</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The cone angle is determined by the detector size and source distance:
cone_angle ≈ 2 * arctan(max(det_u*du, det_v*dv) / (2*source_distance)).
Keep cone angle &lt; 30° to minimize reconstruction artifacts.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="diffct.differentiable.ConeBackprojectorFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">diffct.differentiable.</span></span><span class="sig-name descname"><span class="pre">ConeBackprojectorFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeBackprojectorFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeBackprojectorFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>PyTorch autograd function for differentiable 3D cone beam backprojection.</p>
<p>This class provides a differentiable interface to the CUDA-accelerated Siddon-Joseph
ray-tracing algorithm for 3D cone beam backprojection. It implements the adjoint of the
3D cone beam projection operator, distributing projection values from a 2D detector array
back into a 3D reconstruction volume along divergent ray paths.</p>
<p>The forward pass computes a 3D reconstruction from cone beam projection data using
backprojection with 3D divergent ray geometry. The backward pass computes gradients
using 3D cone beam forward projection, enabling end-to-end differentiable volumetric
CT reconstruction pipelines.</p>
<dl>
<dt>Key Features:</dt><dd><ul class="simple">
<li><p>CUDA-accelerated 3D Siddon-Joseph ray tracing with trilinear interpolation</p></li>
<li><p>Point source to 2D detector array ray path calculations in 3D space</p></li>
<li><p>Thread-safe 3D voxel accumulation using CUDA atomic operations</p></li>
<li><p>Full PyTorch autograd integration for gradient-based optimization</p></li>
<li><p>Optimized 3D memory access patterns and thread organization</p></li>
</ul>
</dd>
<dt>Mathematical Background:</dt><dd><p>3D cone beam backprojection distributes each detector pixel measurement back along
its corresponding 3D ray path from source to detector. The reconstruction process
involves trilinear interpolation for sub-voxel accuracy and atomic operations for
thread-safe accumulation when multiple rays contribute to the same voxel.</p>
<p>Due to the 3D nature and ray convergence, this operation has the highest computational
complexity and memory requirements among all projection operators in DiffCT.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">diffct.differentiable</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConeBackprojectorFunction</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create 3D cone beam projection data with gradient tracking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projections</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define reconstruction parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span>  <span class="c1"># 3D reconstruction size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span>       <span class="c1"># Detector pixel spacing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_distance</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isocenter_distance</span> <span class="o">=</span> <span class="mf">500.0</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute 3D backprojection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">backprojector</span> <span class="o">=</span> <span class="n">ConeBackprojectorFunction</span><span class="o">.</span><span class="n">apply</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">backprojector</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">source_distance</span><span class="p">,</span> <span class="n">isocenter_distance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute loss and gradients</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Projection gradient shape: </span><span class="si">{</span><span class="n">projections</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (360, 256, 256)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>3D cone beam backprojection is the most memory and computationally intensive operation
in DiffCT. Consider using gradient checkpointing, smaller volumes, or distributed
computing for large-scale applications. Ensure sufficient GPU memory is available.</p>
</div>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sinogram</span></code> (torch.Tensor): Input sinogram of shape (num_angles, det_u, det_v)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angles</span></code> (torch.Tensor): Projection angles in radians, shape (num_angles,)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">volume_width</span></code> (int): Width of output volume</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">volume_height</span></code> (int): Height of output volume</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">volume_depth</span></code> (int): Depth of output volume</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">du</span></code> (float): Detector spacing in U direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dv</span></code> (float): Detector spacing in V direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source_distance</span></code> (float): Distance from rotation center to X-ray source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isocenter_distance</span></code> (float): Distance from rotation center to detector</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">volume</span></code> (torch.Tensor): Reconstructed volume of shape (volume_depth, volume_height, volume_width)</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ConeBackprojectorFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeBackprojectorFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeBackprojectorFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Define a formula for differentiating the operation with backward mode automatic differentiation.</p>
<p>This function is to be overridden by all subclasses.
(Defining this function is equivalent to defining the <code class="docutils literal notranslate"><span class="pre">vjp</span></code> function.)</p>
<p>It must accept a context <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx</span></code> as the first argument, followed by
as many outputs as the <a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.forward" title="diffct.differentiable.ConeBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
<a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.forward" title="diffct.differentiable.ConeBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">ctx.needs_input_grad</span></code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
<a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.backward" title="diffct.differentiable.ConeBackprojectorFunction.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">backward()</span></code></a> will have <code class="docutils literal notranslate"><span class="pre">ctx.needs_input_grad[0]</span> <span class="pre">=</span> <span class="pre">True</span></code> if the
first input to <a class="reference internal" href="#diffct.differentiable.ConeBackprojectorFunction.forward" title="diffct.differentiable.ConeBackprojectorFunction.forward"><code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code></a> needs gradient computed w.r.t. the
output.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="diffct.differentiable.ConeBackprojectorFunction.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">du</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isocenter_distance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diffct/differentiable.html#ConeBackprojectorFunction.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#diffct.differentiable.ConeBackprojectorFunction.forward" title="Link to this definition"></a></dt>
<dd><p>Compute 3D cone beam backprojection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – PyTorch autograd context for saving information for backward pass</p></li>
<li><p><strong>sinogram</strong> (<em>torch.Tensor</em>) – Input 3D projection tensor of shape (n_views, det_u, det_v).
Must be on CUDA device. Contains cone beam projection data where each 2D slice
corresponds to one projection view with (u,v) detector coordinates.</p></li>
<li><p><strong>angles</strong> (<em>torch.Tensor</em>) – Projection angles in radians, shape (n_views,). Must be on
same CUDA device as sinogram. Should match angles used in forward projection.</p></li>
<li><p><strong>D</strong> (<em>int</em>) – Depth of the 3D reconstruction volume in pixels (z-direction).</p></li>
<li><p><strong>H</strong> (<em>int</em>) – Height of the 3D reconstruction volume in pixels (y-direction).</p></li>
<li><p><strong>W</strong> (<em>int</em>) – Width of the 3D reconstruction volume in pixels (x-direction).</p></li>
<li><p><strong>du</strong> (<em>float</em>) – Physical spacing between detector pixels in u-direction in mm or other
length units. Must match the spacing used in forward projection.</p></li>
<li><p><strong>dv</strong> (<em>float</em>) – Physical spacing between detector pixels in v-direction in mm or other
length units. Must match the spacing used in forward projection.</p></li>
<li><p><strong>source_distance</strong> (<em>float</em>) – Distance from X-ray source to isocenter in mm or other
length units. Must match the value used in forward projection.</p></li>
<li><p><strong>isocenter_distance</strong> (<em>float</em>) – Distance from isocenter to detector array in mm or other
length units. Must match the value used in forward projection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Reconstructed 3D volume tensor of shape (D, H, W). Values represent</dt><dd><p>the cone beam backprojected reconstruction with 3D geometric effects. For
filtered backprojection, additional 3D filtering may be required.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError</strong> – If CUDA is not available or tensors are not on CUDA device</p></li>
<li><p><strong>ValueError</strong> – If geometry parameters are invalid or inconsistent with projection shape</p></li>
<li><p><strong>MemoryError</strong> – If reconstruction volume is too large for available GPU memory</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>3D cone beam backprojection requires significant GPU memory proportional to
D×H×W×sizeof(float). Monitor GPU memory usage and consider using smaller volumes
or gradient checkpointing for large reconstructions. Ensure geometry parameters
are consistent with forward projection for accurate reconstruction.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="usage-notes">
<h2>Usage Notes<a class="headerlink" href="#usage-notes" title="Link to this heading"></a></h2>
<p><strong>Memory Management:</strong>
- All operators work with GPU tensors for optimal performance
- Ensure sufficient GPU memory for your problem size
- Use <code class="docutils literal notranslate"><span class="pre">torch.cuda.empty_cache()</span></code> if encountering memory issues</p>
<p><strong>Gradient Computation:</strong>
- All operators support automatic differentiation
- Gradients flow through both forward and backward passes
- Set <code class="docutils literal notranslate"><span class="pre">requires_grad=True</span></code> on input tensors to enable gradients</p>
<p><strong>Performance Considerations:</strong>
- Use contiguous tensors for optimal memory access
- Consider batch processing for multiple reconstructions
- Profile your code to identify bottlenecks</p>
<p><strong>Coordinate Systems:</strong>
- Image/volume coordinates: (0,0) at top-left corner
- Detector coordinates: centered at detector array center
- Rotation: counter-clockwise around z-axis (right-hand rule)</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="getting_started.html" class="btn btn-neutral float-left" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Yipeng Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>