

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>diffct.differentiable &mdash; diffct  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            diffct
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffct</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">diffct.differentiable</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for diffct.differentiable</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">cuda</span>

<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># Global settings &amp; helpers</span>
<span class="c1"># ---------------------------------------------------------------------------</span>

<span class="n">_DTYPE</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="c1"># CUDA thread block configurations optimized for different dimensionalities</span>
<span class="c1"># 2D blocks: 16x16 = 256 threads per block, optimal for 2D ray-tracing kernels</span>
<span class="c1"># Balances occupancy with shared memory usage for parallel/fan beam projections</span>
<span class="n">_TPB_2D</span>             <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1"># 3D blocks: 8x8x8 = 512 threads per block, optimal for 3D cone beam kernels  </span>
<span class="c1"># Smaller per-dimension size accommodates higher register usage in 3D algorithms</span>
<span class="n">_TPB_3D</span>             <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">8</span><span class="p">)</span>
<span class="c1"># CUDA fastmath optimization: enables aggressive floating-point optimizations</span>
<span class="c1"># Trades numerical precision for performance in ray-tracing calculations</span>
<span class="c1"># Safe for CT reconstruction where slight precision loss is acceptable for speed gains</span>
<span class="n">_FASTMATH_DECORATOR</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_INF</span>                <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">_EPSILON</span>            <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span>
<span class="c1"># === Device Management Utilities ===</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DeviceManager</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_device</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the device of a PyTorch tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            Tensor whose device to determine.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.device</span>
<span class="sd">            Device of the tensor or CPU if unavailable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DeviceManager.get_device(torch.tensor([1, 2, 3]))</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tensor</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_device</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure a tensor resides on a given device.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            Tensor to move.</span>
<span class="sd">        device : torch.device</span>
<span class="sd">            Desired device.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Tensor on the specified device. Unchanged if already on it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DeviceManager.ensure_device(</span>
<span class="sd">        ...     torch.tensor([1, 2, 3]),</span>
<span class="sd">        ...     torch.device(&#39;cuda&#39;)</span>
<span class="sd">        ... )</span>
<span class="sd">        tensor([1, 2, 3], device=&#39;cuda:0&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tensor</span> <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">device</span> <span class="k">else</span> <span class="n">tensor</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor</span>

<span class="c1"># === PyTorch-CUDA Bridge ===</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TorchCUDABridge</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tensor_to_cuda_array</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a PyTorch CUDA tensor to a Numba CUDA DeviceNDArray.</span>

<span class="sd">        Provides a zero-copy view of a detached PyTorch tensor as a Numba CUDA array,</span>
<span class="sd">        avoiding CPU data transfers. The returned array shares memory with the</span>
<span class="sd">        original tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor : torch.Tensor</span>
<span class="sd">            PyTorch tensor on a CUDA device.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">            Numba CUDA array view sharing memory with `tensor`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `tensor` is not on a CUDA device.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; t = torch.randn(10, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr = TorchCUDABridge.tensor_to_cuda_array(t)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tensor</span><span class="o">.</span><span class="n">is_cuda</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tensor must be on CUDA device&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cuda</span><span class="o">.</span><span class="n">as_cuda_array</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cuda_array_to_tensor</span><span class="p">(</span><span class="n">cuda_array</span><span class="p">,</span> <span class="n">tensor_template</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a Numba CUDA array to a PyTorch tensor.</span>

<span class="sd">        Wrap a Numba CUDA DeviceNDArray as a PyTorch tensor with matching device</span>
<span class="sd">        and dtype from a template tensor, sharing underlying memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cuda_array : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">            Numba CUDA array to wrap.</span>
<span class="sd">        tensor_template : torch.Tensor</span>
<span class="sd">            Template tensor specifying device and dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            PyTorch tensor sharing data with the CUDA array on the template&#39;s</span>
<span class="sd">            device and dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = cuda.device_array((10,), dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; t = torch.zeros(10, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_t = TorchCUDABridge.cuda_array_to_tensor(arr, t)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">cuda_array</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">tensor_template</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_template</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="c1"># === GPU-aware Trigonometric Table Generation ===</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_DTYPE</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute cosine and sine tables for input angles.</span>

<span class="sd">    Precompute cosine and sine values and return as torch tensors on the</span>
<span class="sd">    same device as `angles`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angles : array-like or torch.Tensor</span>
<span class="sd">        Projection angles in radians. Can be a NumPy array or a PyTorch tensor on CPU or CUDA.</span>
<span class="sd">    dtype : numpy.dtype or torch.dtype, optional</span>
<span class="sd">        Desired data type for output tables. Default is `_DTYPE`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cos : torch.Tensor</span>
<span class="sd">        Cosine values of `angles` on the same device.</span>
<span class="sd">    sin : torch.Tensor</span>
<span class="sd">        Sine values of `angles` on the same device.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cos, sin = _trig_tables(angles)</span>
<span class="sd">    &gt;&gt;&gt; cos.device</span>
<span class="sd">    device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">device</span>
        <span class="n">cos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cos</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">sin</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fallback for numpy arrays</span>
        <span class="n">cos_host</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sin_host</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">cos_host</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">sin_host</span><span class="p">)</span>




<span class="k">def</span><span class="w"> </span><span class="nf">_grid_2d</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">tpb</span><span class="o">=</span><span class="n">_TPB_2D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute 2D CUDA grid and block dimensions.</span>

<span class="sd">    Determine optimal grid and block sizes for 2D CUDA ray-tracing kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n1 : int</span>
<span class="sd">        Number of elements along the first dimension (e.g., projection angles).</span>
<span class="sd">    n2 : int</span>
<span class="sd">        Number of elements along the second dimension (e.g., detector elements).</span>
<span class="sd">    tpb : tuple of int, optional</span>
<span class="sd">        Threads per block (default is `_TPB_2D`) to balance occupancy and memory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : tuple of int</span>
<span class="sd">        Blocks count per axis.</span>
<span class="sd">    tpb : tuple of int</span>
<span class="sd">        Threads per block per axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid, tpb = _grid_2d(180, 256)</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    (12, 16)</span>
<span class="sd">    &gt;&gt;&gt; tpb</span>
<span class="sd">    (16, 16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n1</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n2</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">tpb</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_grid_3d</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">tpb</span><span class="o">=</span><span class="n">_TPB_3D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute 3D CUDA grid and block dimensions.</span>

<span class="sd">    Determine optimal grid and block sizes for 3D CUDA cone-beam kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n1 : int</span>
<span class="sd">        Number of elements along the first dimension (e.g., projection views).</span>
<span class="sd">    n2 : int</span>
<span class="sd">        Number of elements along the second dimension (e.g., detector u-axis).</span>
<span class="sd">    n3 : int</span>
<span class="sd">        Number of elements along the third dimension (e.g., detector v-axis).</span>
<span class="sd">    tpb : tuple of int, optional</span>
<span class="sd">        Threads per block (default is `_TPB_3D`) to balance occupancy and registers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : tuple of int</span>
<span class="sd">        Blocks count per axis.</span>
<span class="sd">    tpb : tuple of int</span>
<span class="sd">        Threads per block per axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid, tpb = _grid_3d(360, 256, 256)</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    (45, 32, 32)</span>
<span class="sd">    &gt;&gt;&gt; tpb</span>
<span class="sd">    (8, 8, 8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n1</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n2</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n3</span> <span class="o">/</span> <span class="n">tpb</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
    <span class="p">),</span> <span class="n">tpb</span>


<span class="c1"># ############################################################################</span>
<span class="c1"># SHARED CUDA KERNELS</span>
<span class="c1"># ############################################################################</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 2-D PARALLEL BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_parallel_2d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph ray-tracing algorithm for</span>
<span class="sd">    2D parallel beam forward projection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_image : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input 2D image array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output sinogram array on CUDA.</span>
<span class="sd">    n_ang : int</span>
<span class="sd">        Number of projection angles.</span>
<span class="sd">    n_det : int</span>
<span class="sd">        Number of detector elements.</span>
<span class="sd">    det_spacing : float</span>
<span class="sd">        Physical spacing between detector elements.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of image width in voxels.</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of image height in voxels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Siddon-Joseph algorithm provides accurate ray-volume intersection by:</span>
<span class="sd">      - Calculating ray-volume boundary intersections to define traversal limits.</span>
<span class="sd">      - Iterating through voxels along the ray path via parametric equations.</span>
<span class="sd">      - Determining bilinear interpolation weights for sub-voxel sampling.</span>
<span class="sd">      - Aggregating weighted voxel values based on ray segment lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># CUDA THREAD ORGANIZATION: 2D grid maps directly to ray geometry</span>
    <span class="c1"># Each thread processes one ray defined by (projection_angle, detector_element) pair</span>
    <span class="c1"># Thread indexing: iang = projection angle index, idet = detector element index</span>
    <span class="c1"># Memory access pattern: Threads in same warp access consecutive detector elements (coalesced)</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === RAY GEOMETRY SETUP ===</span>
    <span class="c1"># Extract projection angle and compute detector position</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Define ray direction and starting point for parallel beam geometry</span>
    <span class="c1"># Ray direction is perpendicular to detector array (cos_a, sin_a)</span>
    <span class="c1"># Ray starting point is offset along detector by distance u</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span>
    <span class="n">pnt_x</span><span class="p">,</span> <span class="n">pnt_y</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_a</span><span class="p">,</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute parametric intersection points with volume boundaries using ray equation r(t) = pnt + t*dir</span>
    <span class="c1"># Volume extends from [-cx, cx] x [-cy, cy] in image coordinate system</span>
    <span class="c1"># Mathematical basis: For ray r(t) = origin + t*direction, solve r(t) = boundary for parameter t</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>  <span class="c1"># Initialize ray parameter range to unbounded</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="c1"># Handle non-parallel rays: compute intersection parameters with left (-cx) and right (+cx) boundaries</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Ray not parallel to x-axis (avoid division by zero)</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>  <span class="c1"># Left and right boundary intersections</span>
        <span class="c1"># Update valid parameter range: intersection of current range with x-boundary constraints</span>
        <span class="c1"># min/max operations ensure we get the entry/exit points correctly regardless of ray direction</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>  <span class="c1"># Update valid parameter range</span>
    <span class="k">elif</span> <span class="n">pnt_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">pnt_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Ray parallel to x-axis but outside volume bounds</span>
        <span class="c1"># Edge case: ray never intersects volume if parallel and outside boundaries</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># Y-direction boundary intersections (identical logic to x-direction)</span>
    <span class="c1"># Handle non-parallel rays: compute intersection parameters with bottom (-cy) and top (+cy) boundaries</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Ray not parallel to y-axis (avoid division by zero)</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>  <span class="c1"># Bottom and top boundary intersections</span>
        <span class="c1"># Intersect y-boundary constraints with existing parameter range from x-boundaries</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>  <span class="c1"># Intersect with x-range</span>
    <span class="k">elif</span> <span class="n">pnt_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">pnt_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>  <span class="c1"># Ray parallel to y-axis but outside volume bounds</span>
        <span class="c1"># Edge case: ray never intersects volume if parallel and outside boundaries</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># Boundary intersection validation: check if ray actually intersects the volume</span>
    <span class="c1"># If t_min &gt;= t_max, the ray misses the volume entirely (no valid intersection interval)</span>
    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH VOXEL TRAVERSAL INITIALIZATION ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value along ray</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter (distance from ray start)</span>
    
    <span class="c1"># Convert ray entry point to voxel indices (image coordinate system)</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>

    <span class="c1"># Determine traversal direction and step sizes for each axis</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Voxel stepping direction</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment to cross one voxel in x</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment to cross one voxel in y</span>
    
    <span class="c1"># Calculate parameter values for next voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Next x-boundary crossing</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Next y-boundary crossing</span>

    <span class="c1"># === MAIN RAY TRAVERSAL LOOP ===</span>
    <span class="c1"># Step through voxels along ray path, accumulating weighted contributions</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next voxel boundary crossing (minimum of x, y boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>  <span class="c1"># Length of ray segment within current voxel region</span>
            
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Only process segments with meaningful length (avoid numerical noise)</span>
                <span class="c1"># === BILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample volume at ray segment midpoint for accurate integration</span>
                <span class="c1"># Mathematical basis: Midpoint rule for numerical integration along ray segments</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">pnt_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate in image space</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">pnt_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate in image space</span>
                
                <span class="c1"># Convert continuous coordinates to discrete voxel indices and fractional weights</span>
                <span class="c1"># Floor operation gives base voxel index, fractional part gives interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>  <span class="c1"># Base voxel indices (bottom-left corner)</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>  <span class="c1"># Fractional parts: distance from base voxel center [0,1]</span>
                
                <span class="c1"># === BILINEAR INTERPOLATION WEIGHT CALCULATION ===</span>
                <span class="c1"># Mathematical basis: Bilinear interpolation formula f(x,y) = Î£ f(xi,yi) * wi(x,y)</span>
                <span class="c1"># where wi(x,y) are the bilinear basis functions for each corner voxel</span>
                <span class="c1"># Weights are products of 1D linear interpolation weights: (1-dx) or dx, (1-dy) or dy</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>       <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span>
                <span class="p">)</span>
                <span class="c1"># Accumulate contribution weighted by ray segment length (discrete line integral approximation)</span>
                <span class="c1"># This implements the Radon transform: integral of f(x,y) along the ray path</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>
        
        <span class="c1"># === VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>  <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>  <span class="c1"># Move to next voxel in x-direction</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>    <span class="c1"># Update next x-boundary crossing parameter</span>
        <span class="k">else</span><span class="p">:</span>         <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>  <span class="c1"># Move to next voxel in y-direction</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>    <span class="c1"># Update next y-boundary crossing parameter</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_parallel_2d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D parallel</span>
<span class="sd">    beam backprojection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input sinogram array on CUDA.</span>
<span class="sd">    n_ang : int</span>
<span class="sd">        Number of projection angles.</span>
<span class="sd">    n_det : int</span>
<span class="sd">        Number of detector elements.</span>
<span class="sd">    d_image : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output image gradient array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    det_spacing : float</span>
<span class="sd">        Physical spacing between detector elements.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of image width in voxels.</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of image height in voxels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This operation is the adjoint of the forward projection. Sinogram values</span>
<span class="sd">    are distributed back into the volume along identical ray paths using</span>
<span class="sd">    atomic operations to ensure thread-safe accumulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === RAY GEOMETRY SETUP (identical to forward projection) ===</span>
    <span class="n">val</span>   <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Define ray direction and starting point for parallel beam geometry</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span>
    <span class="n">pnt_x</span><span class="p">,</span> <span class="n">pnt_y</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_a</span><span class="p">,</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION (identical to forward) ===</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">pnt_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">pnt_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">pnt_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">pnt_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pnt_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">pnt_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">pnt_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along ray path using bilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at ray segment midpoint (same as forward projection)</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">pnt_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">pnt_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH BILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA ATOMIC OPERATIONS: Essential for thread safety in backprojection</span>
                <span class="c1"># Multiple threads (rays) can write to the same voxel simultaneously, causing race conditions</span>
                <span class="c1"># Atomic add operations serialize these writes, ensuring correct accumulation of contributions</span>
                <span class="c1"># Performance impact: Atomic operations are slower than regular writes but necessary for correctness</span>
                <span class="c1"># Memory access pattern: Global memory atomics with potential bank conflicts, but unavoidable</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>

        <span class="c1"># Advance to next voxel (identical logic to forward projection)</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 2-D FAN BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_fan_2d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D fan beam</span>
<span class="sd">    forward projection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_image : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input 2D image array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output fan beam sinogram array on CUDA.</span>
<span class="sd">    n_ang : int</span>
<span class="sd">        Number of projection angles.</span>
<span class="sd">    n_det : int</span>
<span class="sd">        Number of detector elements.</span>
<span class="sd">    det_spacing : float</span>
<span class="sd">        Physical spacing between detector elements.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    sdd : float</span>
<span class="sd">        Source-to-Detector Distance (SDD), total distance from source to detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        Source-to-Isocenter Distance (SID), distance from source to isocenter.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of image width in voxels.</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of image height in voxels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Fan beam geometry diverges from parallel beam in that its rays originate</span>
<span class="sd">    from a single point source to a linear detector array. Rays connect the</span>
<span class="sd">    rotated source position around the isocenter to each detector pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === FAN BEAM GEOMETRY SETUP ===</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>  <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Calculate source and detector positions for current projection angle</span>
    <span class="c1"># Source position: rotated by angle around isocenter at distance sid (SID)</span>
    <span class="n">src_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Source x-coordinate in world space</span>
    <span class="n">src_y</span> <span class="o">=</span>  <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span>  <span class="c1"># Source y-coordinate in world space</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># Detector x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Detector y-coordinate</span>

    <span class="c1"># === RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">dir_y</span><span class="p">)</span>  <span class="c1"># Ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Degenerate ray case</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Normalize ray direction vector for parametric traversal</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">inv_len</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>  <span class="c1"># Volume boundary intersections</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Source outside volume bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>  <span class="c1"># No valid intersection</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL (same algorithm as parallel beam) ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter</span>
    
    <span class="c1"># Convert ray entry point to voxel indices (using source as ray origin)</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="c1"># Traversal parameters (identical to parallel beam implementation)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># Main traversal loop with bilinear interpolation (identical to parallel beam)</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># Bilinear interpolation (identical to parallel beam)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>       <span class="o">+</span>
                    <span class="n">d_image</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span>
                <span class="p">)</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>
        
        <span class="c1"># Voxel boundary crossing logic (identical to parallel beam)</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_fan_2d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
    <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
    <span class="n">det_spacing</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 2D fan beam</span>
<span class="sd">    backprojection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input fan beam sinogram array on CUDA.</span>
<span class="sd">    n_ang : int</span>
<span class="sd">        Number of projection angles.</span>
<span class="sd">    n_det : int</span>
<span class="sd">        Number of detector elements.</span>
<span class="sd">    d_image : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output image gradient array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    det_spacing : float</span>
<span class="sd">        Physical spacing between detector elements.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    sdd : float</span>
<span class="sd">        Source-to-Detector Distance (SDD), total distance from source to detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        Source-to-Isocenter Distance (SID), distance from source to isocenter.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of image width in voxels.</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of image height in voxels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As the adjoint to the fan beam forward projection, this operation</span>
<span class="sd">    distributes sinogram values back into the volume along divergent ray</span>
<span class="sd">    paths using atomic operations for thread-safe accumulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iang</span><span class="p">,</span> <span class="n">idet</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iang</span> <span class="o">&gt;=</span> <span class="n">n_ang</span> <span class="ow">or</span> <span class="n">idet</span> <span class="o">&gt;=</span> <span class="n">n_det</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === BACKPROJECTION VALUE AND GEOMETRY SETUP ===</span>
    <span class="n">val</span>   <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iang</span><span class="p">,</span> <span class="n">idet</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject along this ray</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed cosine of projection angle</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iang</span><span class="p">]</span>         <span class="c1"># Precomputed sine of projection angle</span>
    <span class="n">u</span>     <span class="o">=</span> <span class="p">(</span><span class="n">idet</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">det_spacing</span>  <span class="c1"># Detector coordinate (centered)</span>

    <span class="c1"># Calculate source and detector positions for current projection angle</span>
    <span class="c1"># Source position: rotated by angle around isocenter at distance sid (SID)</span>
    <span class="n">src_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Source x-coordinate in world space</span>
    <span class="n">src_y</span> <span class="o">=</span>  <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span>  <span class="c1"># Source y-coordinate in world space</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># Detector x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># Detector y-coordinate</span>

    <span class="c1"># === RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">dir_y</span><span class="p">)</span>  <span class="c1"># Ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># Skip degenerate rays</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>        <span class="c1"># Normalization factor for ray direction</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">=</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="n">inv_len</span>  <span class="c1"># Normalized ray direction vector</span>

    <span class="c1"># === RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>

    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === FAN BEAM BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along divergent ray path using bilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># Sample at ray segment midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH BILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA ATOMIC OPERATIONS: Critical for fan beam backprojection thread safety</span>
                <span class="c1"># Fan beam rays converge at source, creating higher probability of voxel write conflicts</span>
                <span class="c1"># Atomic operations prevent race conditions when multiple divergent rays write to same voxel</span>
                <span class="c1"># Performance consideration: Fan beam geometry may have more atomic contention than parallel beam</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_image</span><span class="p">,</span> <span class="p">(</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span>       <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>

        <span class="c1"># === VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>

<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1"># 3-D CONE BEAM KERNELS</span>
<span class="c1"># ------------------------------------------------------------------</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cone_3d_forward_kernel</span><span class="p">(</span>
    <span class="n">d_vol</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone-beam forward projection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 3D cone-beam</span>
<span class="sd">    forward projection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_vol : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input 3D volume array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    Nz : int</span>
<span class="sd">        Number of voxels along the z-axis.</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output cone-beam sinogram array on CUDA.</span>
<span class="sd">    n_views : int</span>
<span class="sd">        Number of projection views.</span>
<span class="sd">    n_u : int</span>
<span class="sd">        Number of detector elements along the u-axis.</span>
<span class="sd">    n_v : int</span>
<span class="sd">        Number of detector elements along the v-axis.</span>
<span class="sd">    du : float</span>
<span class="sd">        Physical spacing between detector elements along the u-axis.</span>
<span class="sd">    dv : float</span>
<span class="sd">        Physical spacing between detector elements along the v-axis.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    sdd : float</span>
<span class="sd">        Source-to-Detector Distance (SDD), total distance from source to detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        Source-to-Isocenter Distance (SID), distance from source to isocenter.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of volume width along x-axis (in voxels).</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of volume height along y-axis (in voxels).</span>
<span class="sd">    cz : float</span>
<span class="sd">        Half of volume depth along z-axis (in voxels).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Cone-beam geometry extends the fan-beam configuration to 3D by employing</span>
<span class="sd">    a 2D detector array and trilinear interpolation for accurate volumetric</span>
<span class="sd">    sampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iview</span> <span class="o">&gt;=</span> <span class="n">n_views</span> <span class="ow">or</span> <span class="n">iu</span> <span class="o">&gt;=</span> <span class="n">n_u</span> <span class="ow">or</span> <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">n_v</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === 3D CONE BEAM GEOMETRY SETUP ===</span>
    <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iview</span><span class="p">],</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iview</span><span class="p">]</span>  <span class="c1"># Projection angle trigonometry</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">iu</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="p">,</span> <span class="p">(</span><span class="n">iv</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dv</span>  <span class="c1"># Detector coordinates (centered)</span>

    <span class="c1"># Calculate 3D source and detector positions</span>
    <span class="c1"># Source rotates in xy-plane around isocenter, z-coordinate is zero</span>
    <span class="n">src_x</span><span class="p">,</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">src_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="mf">0.0</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="c1"># u-coordinate is in-plane offset, v-coordinate is vertical (z-direction)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># In-plane x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># In-plane y-coordinate  </span>
    <span class="n">det_z</span> <span class="o">=</span> <span class="n">v</span>                                           <span class="c1"># Vertical z-coordinate</span>

    <span class="c1"># === 3D RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element in 3D space</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">det_z</span> <span class="o">-</span> <span class="n">src_z</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span><span class="o">*</span><span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">dir_y</span> <span class="o">+</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">dir_z</span><span class="p">)</span>  <span class="c1"># 3D ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span>  <span class="c1"># Degenerate ray case</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Normalize 3D ray direction vector for parametric traversal</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">dir_x</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">inv_len</span>

    <span class="c1"># === 3D RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with 3D volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span>  <span class="c1"># Source outside x-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Y-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span>  <span class="c1"># Source outside y-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>
    
    <span class="c1"># Z-direction boundary intersections (extends 2D algorithm to 3D)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">,</span> <span class="p">(</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cz</span> <span class="ow">or</span> <span class="n">src_z</span> <span class="o">&gt;</span> <span class="n">cz</span><span class="p">:</span>  <span class="c1"># Source outside z-bounds</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span>  <span class="c1"># No valid 3D intersection</span>
        <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">return</span>

    <span class="c1"># === 3D SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">accum</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Accumulated projection value</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>    <span class="c1"># Current ray parameter</span>
    
    <span class="c1"># Convert 3D ray entry point to voxel indices</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_z</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span><span class="p">))</span>  <span class="c1"># Current voxel z-index</span>

    <span class="c1"># 3D traversal parameters (extends 2D algorithm)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span><span class="p">,</span> <span class="n">step_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per x-voxel</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per y-voxel</span>
    <span class="n">dt_z</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per z-voxel</span>
    
    <span class="c1"># Calculate parameter values for next 3D voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="p">((</span><span class="n">iz</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === 3D TRAVERSAL LOOP WITH TRILINEAR INTERPOLATION ===</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current 3D voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next 3D voxel boundary crossing (minimum of x, y, z boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># === TRILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample 3D volume at ray segment midpoint for accurate integration</span>
                <span class="c1"># Mathematical basis: Midpoint rule for numerical integration along 3D ray segments</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate in volume space</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate in volume space</span>
                <span class="n">mid_z</span> <span class="o">=</span> <span class="n">src_z</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span>  <span class="c1"># Midpoint z-coordinate in volume space</span>
                
                <span class="c1"># Convert continuous 3D coordinates to discrete voxel indices and fractional weights</span>
                <span class="c1"># Floor operation gives base voxel index, fractional part gives interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_z</span><span class="p">))</span>  <span class="c1"># Base voxel indices (corner 0,0,0)</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">mid_z</span> <span class="o">-</span> <span class="n">iz0</span>  <span class="c1"># Fractional parts: distance from base voxel center [0,1]</span>
                
                <span class="c1"># === TRILINEAR INTERPOLATION WEIGHT CALCULATION ===</span>
                <span class="c1"># Mathematical basis: Trilinear interpolation formula f(x,y,z) = Î£ f(xi,yi,zi) * wi(x,y,z)</span>
                <span class="c1"># where wi(x,y,z) are the trilinear basis functions for each corner voxel of the 3D cube</span>
                <span class="c1"># Weights are products of 1D linear interpolation weights: (1-dx) or dx, (1-dy) or dy, (1-dz) or dz</span>
                <span class="c1"># Each of the 8 cube corners gets a weight proportional to its distance from the sample point</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dz</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dz</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dz</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dz</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">*</span> <span class="n">dz</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span> <span class="o">*</span> <span class="n">dz</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">]</span>     <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dz</span> <span class="o">+</span>
                    <span class="n">d_vol</span><span class="p">[</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dz</span>
                <span class="p">)</span>
                <span class="c1"># Accumulate contribution weighted by 3D ray segment length (discrete line integral approximation)</span>
                <span class="c1"># This implements the 3D Radon transform: integral of f(x,y,z) along the ray path</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">seg_len</span>

        <span class="c1"># === 3D VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first in 3D</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span> <span class="ow">and</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>      <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">elif</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tx</span> <span class="ow">and</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>    <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
        <span class="k">else</span><span class="p">:</span>                          <span class="c1"># Z-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tz</span>
            <span class="n">iz</span> <span class="o">+=</span> <span class="n">step_z</span>
            <span class="n">tz</span> <span class="o">+=</span> <span class="n">dt_z</span>
    
    <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="n">accum</span>

<span class="nd">@_FASTMATH_DECORATOR</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cone_3d_backward_kernel</span><span class="p">(</span>
    <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
    <span class="n">d_vol</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
    <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span>
    <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone-beam backprojection.</span>

<span class="sd">    This CUDA kernel implements the Siddon-Joseph algorithm for 3D cone-beam</span>
<span class="sd">    backprojection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_sino : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Input cone-beam sinogram array on CUDA.</span>
<span class="sd">    n_views : int</span>
<span class="sd">        Number of projection views.</span>
<span class="sd">    n_u : int</span>
<span class="sd">        Number of detector elements along the u-axis.</span>
<span class="sd">    n_v : int</span>
<span class="sd">        Number of detector elements along the v-axis.</span>
<span class="sd">    d_vol : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Output 3D volume gradient array on CUDA.</span>
<span class="sd">    Nx : int</span>
<span class="sd">        Number of voxels along the x-axis.</span>
<span class="sd">    Ny : int</span>
<span class="sd">        Number of voxels along the y-axis.</span>
<span class="sd">    Nz : int</span>
<span class="sd">        Number of voxels along the z-axis.</span>
<span class="sd">    du : float</span>
<span class="sd">        Physical spacing between detector elements along the u-axis.</span>
<span class="sd">    dv : float</span>
<span class="sd">        Physical spacing between detector elements along the v-axis.</span>
<span class="sd">    d_cos : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed cosine values of projection angles.</span>
<span class="sd">    d_sin : numba.cuda.cudadrv.devicearray.DeviceNDArray</span>
<span class="sd">        Precomputed sine values of projection angles.</span>
<span class="sd">    sdd : float</span>
<span class="sd">        Source-to-Detector Distance (SDD), total distance from source to detector.</span>
<span class="sd">    sid : float</span>
<span class="sd">        Source-to-Isocenter Distance (SID), distance from source to isocenter.</span>
<span class="sd">    cx : float</span>
<span class="sd">        Half of volume width along x-axis (in voxels).</span>
<span class="sd">    cy : float</span>
<span class="sd">        Half of volume height along y-axis (in voxels).</span>
<span class="sd">    cz : float</span>
<span class="sd">        Half of volume depth along z-axis (in voxels).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As the adjoint to the cone-beam forward projection, this operation</span>
<span class="sd">    distributes sinogram values back into the 3D volume along ray paths using</span>
<span class="sd">    atomic operations for thread-safe accumulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iview</span> <span class="o">&gt;=</span> <span class="n">n_views</span> <span class="ow">or</span> <span class="n">iu</span> <span class="o">&gt;=</span> <span class="n">n_u</span> <span class="ow">or</span> <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">n_v</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># === 3D BACKPROJECTION VALUE AND GEOMETRY SETUP ===</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">d_sino</span><span class="p">[</span><span class="n">iview</span><span class="p">,</span> <span class="n">iu</span><span class="p">,</span> <span class="n">iv</span><span class="p">]</span>  <span class="c1"># Sinogram value to backproject along this ray</span>
    <span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span> <span class="o">=</span> <span class="n">d_cos</span><span class="p">[</span><span class="n">iview</span><span class="p">],</span> <span class="n">d_sin</span><span class="p">[</span><span class="n">iview</span><span class="p">]</span>  <span class="c1"># Projection angle trigonometry</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">iu</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="p">,</span> <span class="p">(</span><span class="n">iv</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dv</span>  <span class="c1"># Detector coordinates (centered)</span>

    <span class="c1"># Calculate 3D source and detector positions</span>
    <span class="c1"># Source rotates in xy-plane around isocenter, z-coordinate is zero</span>
    <span class="n">src_x</span><span class="p">,</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">src_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">sid</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">sid</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="mf">0.0</span>
    
    <span class="c1"># Detector element position: IDD = SDD - SID (Isocenter-to-Detector Distance)</span>
    <span class="c1"># u-coordinate is in-plane offset, v-coordinate is vertical (z-direction)</span>
    <span class="n">idd</span> <span class="o">=</span> <span class="n">sdd</span> <span class="o">-</span> <span class="n">sid</span>
    <span class="n">det_x</span> <span class="o">=</span> <span class="n">idd</span> <span class="o">*</span> <span class="n">sin_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cos_a</span>   <span class="c1"># In-plane x-coordinate</span>
    <span class="n">det_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">idd</span> <span class="o">*</span> <span class="n">cos_a</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sin_a</span>  <span class="c1"># In-plane y-coordinate</span>
    <span class="n">det_z</span> <span class="o">=</span> <span class="n">v</span>                                           <span class="c1"># Vertical z-coordinate</span>

    <span class="c1"># === 3D RAY DIRECTION CALCULATION ===</span>
    <span class="c1"># Ray direction vector from source to detector element in 3D space</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">det_x</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">,</span> <span class="n">det_y</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">,</span> <span class="n">det_z</span> <span class="o">-</span> <span class="n">src_z</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dir_x</span><span class="o">*</span><span class="n">dir_x</span> <span class="o">+</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">dir_y</span> <span class="o">+</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">dir_z</span><span class="p">)</span>  <span class="c1"># 3D ray length</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">_EPSILON</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># Skip degenerate rays</span>
    <span class="n">inv_len</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">length</span>        <span class="c1"># Normalization factor for ray direction</span>
    <span class="n">dir_x</span><span class="p">,</span> <span class="n">dir_y</span><span class="p">,</span> <span class="n">dir_z</span> <span class="o">=</span> <span class="n">dir_x</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_y</span><span class="o">*</span><span class="n">inv_len</span><span class="p">,</span> <span class="n">dir_z</span><span class="o">*</span><span class="n">inv_len</span>  <span class="c1"># Normalized 3D ray direction vector</span>

    <span class="c1"># === 3D RAY-VOLUME INTERSECTION CALCULATION ===</span>
    <span class="c1"># Compute intersection with 3D volume boundaries using source position as ray origin</span>
    <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">_INF</span><span class="p">,</span> <span class="n">_INF</span>
    
    <span class="c1"># X-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span> <span class="n">tx2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cx</span> <span class="ow">or</span> <span class="n">src_x</span> <span class="o">&gt;</span> <span class="n">cx</span><span class="p">:</span> <span class="k">return</span>
    
    <span class="c1"># Y-direction boundary intersections</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ty1</span><span class="p">,</span> <span class="n">ty2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cy</span> <span class="ow">or</span> <span class="n">src_y</span> <span class="o">&gt;</span> <span class="n">cy</span><span class="p">:</span> <span class="k">return</span>
    
    <span class="c1"># Z-direction boundary intersections (extends 2D algorithm to 3D)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
        <span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">,</span> <span class="p">(</span><span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span>
        <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">t_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tz1</span><span class="p">,</span> <span class="n">tz2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">src_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cz</span> <span class="ow">or</span> <span class="n">src_z</span> <span class="o">&gt;</span> <span class="n">cz</span><span class="p">:</span> <span class="k">return</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&gt;=</span> <span class="n">t_max</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># === 3D SIDDON-JOSEPH TRAVERSAL INITIALIZATION ===</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_x</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span><span class="p">))</span>  <span class="c1"># Current voxel x-index</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_y</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># Current voxel y-index</span>
    <span class="n">iz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">src_z</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span><span class="p">))</span>  <span class="c1"># Current voxel z-index</span>

    <span class="c1"># 3D traversal parameters (extends 2D algorithm)</span>
    <span class="n">step_x</span><span class="p">,</span> <span class="n">step_y</span><span class="p">,</span> <span class="n">step_z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">dir_z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dt_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per x-voxel</span>
    <span class="n">dt_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per y-voxel</span>
    <span class="n">dt_z</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dir_z</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>  <span class="c1"># Parameter increment per z-voxel</span>
    
    <span class="c1"># Calculate parameter values for next 3D voxel boundary crossings</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">ix</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">src_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_x</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="p">((</span><span class="n">iy</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">src_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_y</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>
    <span class="n">tz</span> <span class="o">=</span> <span class="p">((</span><span class="n">iz</span> <span class="o">+</span> <span class="p">(</span><span class="n">step_z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">src_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dir_z</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dir_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span> <span class="k">else</span> <span class="n">_INF</span>

    <span class="c1"># === 3D CONE BEAM BACKPROJECTION TRAVERSAL LOOP ===</span>
    <span class="c1"># Distribute sinogram value along divergent 3D ray path using trilinear interpolation</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
        <span class="c1"># Check if current 3D voxel indices are within valid interpolation bounds</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine next 3D voxel boundary crossing (minimum of x, y, z boundaries or ray exit)</span>
            <span class="n">t_next</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">t_max</span><span class="p">)</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">t_next</span> <span class="o">-</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">seg_len</span> <span class="o">&gt;</span> <span class="n">_EPSILON</span><span class="p">:</span>
                <span class="c1"># === TRILINEAR INTERPOLATION SAMPLING ===</span>
                <span class="c1"># Sample 3D volume at ray segment midpoint using source as ray origin</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_x</span> <span class="o">+</span> <span class="n">cx</span>  <span class="c1"># Midpoint x-coordinate</span>
                <span class="n">mid_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_y</span> <span class="o">+</span> <span class="n">cy</span>  <span class="c1"># Midpoint y-coordinate</span>
                <span class="n">mid_z</span> <span class="o">=</span> <span class="n">src_z</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">seg_len</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dir_z</span> <span class="o">+</span> <span class="n">cz</span>  <span class="c1"># Midpoint z-coordinate</span>
                
                <span class="c1"># Convert continuous 3D coordinates to voxel indices and interpolation weights</span>
                <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">iz0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_x</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_y</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mid_z</span><span class="p">))</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">mid_x</span> <span class="o">-</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">mid_y</span> <span class="o">-</span> <span class="n">iy0</span><span class="p">,</span> <span class="n">mid_z</span> <span class="o">-</span> <span class="n">iz0</span>  <span class="c1"># Fractional parts for 3D weights</span>
                
                <span class="c1"># === ATOMIC BACKPROJECTION WITH TRILINEAR WEIGHTS ===</span>
                <span class="c1"># Distribute contribution weighted by segment length and interpolation weights</span>
                <span class="c1"># CUDA 3D ATOMIC OPERATIONS: Most complex atomic pattern in cone beam backprojection</span>
                <span class="c1"># 8 atomic writes per ray segment (one per cube corner) increases memory contention significantly</span>
                <span class="c1"># Cone beam geometry creates maximum ray convergence, highest probability of write conflicts</span>
                <span class="c1"># Performance impact: 3D atomics are most expensive due to volume of concurrent writes</span>
                <span class="c1"># Memory bandwidth: 8 atomic operations per interpolation point can saturate memory subsystem</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">seg_len</span>  <span class="c1"># Contribution value for this ray segment</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span><span class="p">,</span>     <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dz</span><span class="p">))</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">),</span>     <span class="n">cval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d_vol</span><span class="p">,</span> <span class="p">(</span><span class="n">iz0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cval</span> <span class="o">*</span> <span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>

        <span class="c1"># === 3D VOXEL BOUNDARY CROSSING LOGIC ===</span>
        <span class="c1"># Advance to next voxel based on which boundary is crossed first in 3D</span>
        <span class="k">if</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">ty</span> <span class="ow">and</span> <span class="n">tx</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>      <span class="c1"># X-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tx</span>
            <span class="n">ix</span> <span class="o">+=</span> <span class="n">step_x</span>
            <span class="n">tx</span> <span class="o">+=</span> <span class="n">dt_x</span>
        <span class="k">elif</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tx</span> <span class="ow">and</span> <span class="n">ty</span> <span class="o">&lt;=</span> <span class="n">tz</span><span class="p">:</span>    <span class="c1"># Y-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ty</span>
            <span class="n">iy</span> <span class="o">+=</span> <span class="n">step_y</span>
            <span class="n">ty</span> <span class="o">+=</span> <span class="n">dt_y</span>
        <span class="k">else</span><span class="p">:</span>                          <span class="c1"># Z-boundary crossed first</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tz</span>
            <span class="n">iz</span> <span class="o">+=</span> <span class="n">step_z</span>
            <span class="n">tz</span> <span class="o">+=</span> <span class="n">dt_z</span>


<span class="c1"># ############################################################################</span>
<span class="c1"># DIFFERENTIABLE TORCH FUNCTIONS</span>
<span class="c1"># ############################################################################</span>

<div class="viewcode-block" id="ParallelProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 2D parallel beam forward projection.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for parallel beam CT geometry. The forward pass computes</span>
<span class="sd">    the sinogram from a 2D image using parallel beam geometry. The backward pass</span>
<span class="sd">    computes gradients using the adjoint backprojection operation. Requires</span>
<span class="sd">    CUDA-capable hardware and a properly configured CUDA environment; all input</span>
<span class="sd">    tensors must reside on the same CUDA device.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import ParallelProjectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Create a 2D image with gradient tracking</span>
<span class="sd">    &gt;&gt;&gt; image = torch.randn(128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; # Define projection parameters</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; num_detectors = 128</span>
<span class="sd">    &gt;&gt;&gt; detector_spacing = 1.0</span>
<span class="sd">    &gt;&gt;&gt; # Compute forward projection</span>
<span class="sd">    &gt;&gt;&gt; projector = ParallelProjectorFunction.apply</span>
<span class="sd">    &gt;&gt;&gt; sinogram = projector(image, angles, num_detectors, detector_spacing)</span>
<span class="sd">    &gt;&gt;&gt; # Compute loss and gradients</span>
<span class="sd">    &gt;&gt;&gt; loss = sinogram.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;Gradient shape: {image.grad.shape}&quot;)  # (128, 128)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ParallelProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam forward projection (Radon transform) of</span>
<span class="sd">        an image using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : torch.Tensor</span>
<span class="sd">            2D input image tensor of shape (H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `image`.</span>
<span class="sd">        num_detectors : int</span>
<span class="sd">            Number of detector elements in the sinogram (columns).</span>
<span class="sd">        detector_spacing : float, optional</span>
<span class="sd">            Physical spacing between detector elements (default: 1.0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D tensor of shape (num_angles, num_detectors) containing the forward projection (sinogram) on the same device as `image`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sinogram = ParallelProjectorFunction.apply(</span>
<span class="sd">        ...     image, angles, 128, 1.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="c1"># Ensure input is float32 for kernel compatibility</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_image</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sinogram</span></div>


<div class="viewcode-block" id="ParallelProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelProjectorFunction.backward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">grad_image</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_img_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_image</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">d_img_grad</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_image</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ParallelBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 2D parallel beam backprojection.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph ray-tracing</span>
<span class="sd">    algorithm for parallel beam backprojection. The forward pass computes a 2D</span>
<span class="sd">    reconstruction from sinogram data using parallel beam backprojection, and the</span>
<span class="sd">    backward pass computes gradients via forward projection as the adjoint operation.</span>
<span class="sd">    Requires CUDA-capable hardware and consistent device placements.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import ParallelBackprojectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; sinogram = torch.randn(180, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; recon = ParallelBackprojectorFunction.apply(sinogram, angles, 1.0, 128, 128)</span>
<span class="sd">    &gt;&gt;&gt; loss = recon.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(sinogram.grad.shape)  # (180, 128)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ParallelBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 2D parallel beam backprojection (adjoint Radon</span>
<span class="sd">        transform) of a sinogram using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D input sinogram tensor of shape (num_angles, num_detectors), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        detector_spacing : float, optional</span>
<span class="sd">            Physical spacing between detector elements (default: 1.0).</span>
<span class="sd">        H : int, optional</span>
<span class="sd">            Height of the output reconstruction image (default: 128).</span>
<span class="sd">        W : int, optional</span>
<span class="sd">            Width of the output reconstruction image (default: 128).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reco : torch.Tensor</span>
<span class="sd">            2D tensor of shape (H, W) containing the reconstructed image on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(180, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, torch.pi, 180, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; reco = ParallelBackprojectorFunction.apply(</span>
<span class="sd">        ...     sinogram, angles, 1.0, 128, 128</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="c1"># Ensure input is float32 for kernel compatibility</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span>
    
        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">reco</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">reco</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">reco</span></div>


<div class="viewcode-block" id="ParallelBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ParallelBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Allocate output tensor on the same device</span>
        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare trigonometric tables on the correct device</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get Numba CUDA array views for kernel</span>
        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_parallel_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="FanProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FanProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 2D fan beam forward projection.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for fan beam geometry, where rays diverge from a point</span>
<span class="sd">    X-ray source to a linear detector array. The forward pass computes sinograms</span>
<span class="sd">    using divergent beam geometry, and the backward pass computes gradients via</span>
<span class="sd">    adjoint backprojection.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import FanProjectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; image = torch.randn(256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sinogram = FanProjectorFunction.apply(image, angles, 512, 1.0, 1500.0, 1000.0)</span>
<span class="sd">    &gt;&gt;&gt; loss = sinogram.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(image.grad.shape)  # (256, 256)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FanProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam forward projection of an image using CUDA</span>
<span class="sd">        acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : torch.Tensor</span>
<span class="sd">            2D input image tensor of shape (H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `image`.</span>
<span class="sd">        num_detectors : int</span>
<span class="sd">            Number of detector elements in the sinogram (columns).</span>
<span class="sd">        detector_spacing : float</span>
<span class="sd">            Physical spacing between detector elements.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D tensor of shape (num_angles, num_detectors) containing the fan beam sinogram on the same device as `image`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Fan beam geometry uses divergent rays from a point source to the detector.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = torch.randn(256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sinogram = FanProjectorFunction.apply(</span>
<span class="sd">        ...     image, angles, 512, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_ang</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_image</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_image</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">num_detectors</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_detectors</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sinogram</span></div>


<div class="viewcode-block" id="FanProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanProjectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">n_det</span><span class="p">,</span> <span class="n">det_spacing</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">grad_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_img_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_img</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_img_grad</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">det_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_img</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="FanBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FanBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 2D fan beam backprojection.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for fan beam backprojection. Implements the adjoint</span>
<span class="sd">    of the fan beam projection operator, distributing sinogram values back into</span>
<span class="sd">    the reconstruction volume along divergent ray paths. The forward pass</span>
<span class="sd">    computes reconstruction from sinogram data, and the backward pass computes</span>
<span class="sd">    gradients via forward projection.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import FanBackprojectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; sinogram = torch.randn(360, 512, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; recon = FanBackprojectorFunction.apply(sinogram, angles, 1.0, 256, 256, 1500.0, 1000.0)</span>
<span class="sd">    &gt;&gt;&gt; loss = recon.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(sinogram.grad.shape)  # (360, 512)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FanBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 2D fan beam backprojection of a sinogram using CUDA</span>
<span class="sd">        acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            2D input fan beam sinogram tensor of shape (num_angles, num_detectors), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_angles,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        detector_spacing : float</span>
<span class="sd">            Physical spacing between detector elements.</span>
<span class="sd">        H : int</span>
<span class="sd">            Height of the output reconstruction image.</span>
<span class="sd">        W : int</span>
<span class="sd">            Width of the output reconstruction image.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reco : torch.Tensor</span>
<span class="sd">            2D tensor of shape (H, W) containing the reconstructed image on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Fan beam geometry uses divergent rays from a point source to the detector.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate ray tracing and bilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sinogram = torch.randn(360, 512, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; reco = FanBackprojectorFunction.apply(</span>
<span class="sd">        ...     sinogram, angles, 1.0, 256, 256, 1000.0, 500.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span>
    
        <span class="n">reco</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">reco</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">detector_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">detector_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reco</span></div>


<div class="viewcode-block" id="FanBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.FanBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">det_spacing</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_2d</span><span class="p">(</span><span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">_fan_2d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_ang</span><span class="p">,</span> <span class="n">n_det</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">det_spacing</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ConeProjectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConeProjectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 3D cone beam forward projection.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for 3D cone beam geometry. Rays emanate from a point</span>
<span class="sd">    X-ray source to a 2D detector array capturing volumetric projection data.</span>
<span class="sd">    The forward pass computes 3D projections, and the backward pass computes</span>
<span class="sd">    gradients via adjoint 3D backprojection. Requires significant GPU memory.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import ConeProjectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; volume = torch.randn(128, 128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; projections = ConeProjectorFunction.apply(volume, angles, 256, 256, 1.0, 1.0, 1500.0, 1000.0)</span>
<span class="sd">    &gt;&gt;&gt; loss = projections.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(volume.grad.shape)  # (128, 128, 128)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ConeProjectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone beam forward projection of a volume using CUDA</span>
<span class="sd">        acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        volume : torch.Tensor</span>
<span class="sd">            3D input volume tensor of shape (D, H, W), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_views,), must be on the same CUDA device as `volume`.</span>
<span class="sd">        det_u : int</span>
<span class="sd">            Number of detector elements along the u-axis (width).</span>
<span class="sd">        det_v : int</span>
<span class="sd">            Number of detector elements along the v-axis (height).</span>
<span class="sd">        du : float</span>
<span class="sd">            Physical spacing between detector elements along the u-axis.</span>
<span class="sd">        dv : float</span>
<span class="sd">            Physical spacing between detector elements along the v-axis.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sino : torch.Tensor</span>
<span class="sd">            3D tensor of shape (num_views, det_u, det_v) containing the cone beam projections on the same device as `volume`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Cone beam geometry uses a point source and a 2D detector array.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate 3D ray tracing and trilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; volume = torch.randn(128, 128, 128, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sino = ConeProjectorFunction.apply(</span>
<span class="sd">        ...     volume, angles, 256, 256, 1.0, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_vol</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    
        <span class="n">_cone_3d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_vol</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span> <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>
    
        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sino</span></div>


<div class="viewcode-block" id="ConeProjectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeProjectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_sinogram</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
         <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_sinogram</span> <span class="o">=</span> <span class="n">grad_sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">grad_vol</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sinogram</span><span class="p">)</span>
        <span class="n">d_vol_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_vol</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    
        <span class="n">_cone_3d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">det_u</span><span class="p">,</span> <span class="n">det_v</span><span class="p">,</span> <span class="n">d_vol_grad</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_vol</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="ConeBackprojectorFunction">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConeBackprojectorFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary</span>
<span class="sd">    -------</span>
<span class="sd">    PyTorch autograd function for differentiable 3D cone beam backprojection.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Provides a differentiable interface to the CUDA-accelerated Siddon-Joseph</span>
<span class="sd">    ray-tracing algorithm for 3D cone beam backprojection. The forward pass</span>
<span class="sd">    computes a 3D reconstruction from cone beam projection data using</span>
<span class="sd">    backprojection as the adjoint operation. The backward pass computes gradients</span>
<span class="sd">    via 3D cone beam forward projection. Requires CUDA-capable hardware and</span>
<span class="sd">    consistent device placements.</span>
<span class="sd">    </span>
<span class="sd">    This operation may be memory- and computationally-intensive due to 3D geometry.</span>
<span class="sd">    Consider using gradient checkpointing, smaller volumes, or distributed computing</span>
<span class="sd">    for large-scale applications, and ensure sufficient GPU memory is available.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from diffct.differentiable import ConeBackprojectorFunction</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; projections = torch.randn(360, 256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">    &gt;&gt;&gt; angles = torch.linspace(0, 2 * torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">    &gt;&gt;&gt; D, H, W = 128, 128, 128</span>
<span class="sd">    &gt;&gt;&gt; du, dv = 1.0, 1.0</span>
<span class="sd">    &gt;&gt;&gt; sdd, sid = 1500.0, 1000.0</span>
<span class="sd">    &gt;&gt;&gt; backprojector = ConeBackprojectorFunction.apply</span>
<span class="sd">    &gt;&gt;&gt; volume = backprojector(projections, angles, D, H, W, du, dv, sdd, sid)</span>
<span class="sd">    &gt;&gt;&gt; loss = volume.sum()</span>
<span class="sd">    &gt;&gt;&gt; loss.backward()</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;Projection gradient shape: {projections.grad.shape}&quot;)  # (360, 256, 256)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ConeBackprojectorFunction.forward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction.forward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sinogram</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the 3D cone beam backprojection of a projection sinogram</span>
<span class="sd">        using CUDA acceleration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sinogram : torch.Tensor</span>
<span class="sd">            3D input cone beam projection tensor of shape (num_views, det_u, det_v), must be on a CUDA device and of type float32.</span>
<span class="sd">        angles : torch.Tensor</span>
<span class="sd">            1D tensor of projection angles in radians, shape (num_views,), must be on the same CUDA device as `sinogram`.</span>
<span class="sd">        D : int</span>
<span class="sd">            Depth (z-dimension) of the output reconstruction volume.</span>
<span class="sd">        H : int</span>
<span class="sd">            Height (y-dimension) of the output reconstruction volume.</span>
<span class="sd">        W : int</span>
<span class="sd">            Width (x-dimension) of the output reconstruction volume.</span>
<span class="sd">        du : float</span>
<span class="sd">            Physical spacing between detector elements along the u-axis.</span>
<span class="sd">        dv : float</span>
<span class="sd">            Physical spacing between detector elements along the v-axis.</span>
<span class="sd">        sdd : float</span>
<span class="sd">            Source-to-Detector Distance (SDD). The total distance from the X-ray</span>
<span class="sd">            source to the detector, passing through the isocenter.</span>
<span class="sd">        sid : float</span>
<span class="sd">            Source-to-Isocenter Distance (SID). The distance from the X-ray</span>
<span class="sd">            source to the center of rotation (isocenter).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol : torch.Tensor</span>
<span class="sd">            3D tensor of shape (D, H, W) containing the reconstructed volume on the same device as `sinogram`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All input tensors must be on the same CUDA device.</span>
<span class="sd">        - The operation is fully differentiable and supports autograd.</span>
<span class="sd">        - Cone beam geometry uses a point source and a 2D detector array.</span>
<span class="sd">        - Uses the Siddon-Joseph algorithm for accurate 3D ray tracing and trilinear interpolation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; projections = torch.randn(360, 256, 256, device=&#39;cuda&#39;, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; angles = torch.linspace(0, 2*torch.pi, 360, device=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; vol = ConeBackprojectorFunction.apply(</span>
<span class="sd">        ...     projections, angles, 128, 128, 128, 1.0, 1.0, 1500.0, 1000.0</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">sinogram</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sinogram</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_sino</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
        <span class="n">d_reco</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">Nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    
        <span class="n">_cone_3d_backward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_sino</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">d_reco</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
                            <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vol</span></div>


<div class="viewcode-block" id="ConeBackprojectorFunction.backward">
<a class="viewcode-back" href="../../api.html#diffct.differentiable.ConeBackprojectorFunction.backward">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_output</span><span class="p">):</span>
        <span class="n">angles</span><span class="p">,</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>
        <span class="p">(</span><span class="n">Nz</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span>
         <span class="n">sdd</span><span class="p">,</span> <span class="n">sid</span><span class="p">)</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">intermediate</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">grad_output</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">DeviceManager</span><span class="o">.</span><span class="n">ensure_device</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">grad_output</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">n_views</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">grad_sino</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">d_cos</span><span class="p">,</span> <span class="n">d_sin</span> <span class="o">=</span> <span class="n">_trig_tables</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grad_output</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">d_grad_out</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_output</span><span class="p">)</span>
        <span class="n">d_sino_grad</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">grad_sino</span><span class="p">)</span>
        <span class="n">d_cos_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_cos</span><span class="p">)</span>
        <span class="n">d_sin_arr</span> <span class="o">=</span> <span class="n">TorchCUDABridge</span><span class="o">.</span><span class="n">tensor_to_cuda_array</span><span class="p">(</span><span class="n">d_sin</span><span class="p">)</span>

        <span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span> <span class="o">=</span> <span class="n">_grid_3d</span><span class="p">(</span><span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">grad_output</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">W</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">H</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">((</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    
        <span class="n">_cone_3d_forward_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">,</span> <span class="n">tpb</span><span class="p">](</span>
            <span class="n">d_grad_out</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">d_sino_grad</span><span class="p">,</span> <span class="n">n_views</span><span class="p">,</span> <span class="n">n_u</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span> <span class="n">d_cos_arr</span><span class="p">,</span> <span class="n">d_sin_arr</span><span class="p">,</span>
            <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sdd</span><span class="p">),</span> <span class="n">_DTYPE</span><span class="p">(</span><span class="n">sid</span><span class="p">),</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_sino</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Yipeng Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>